---
URL: https://www.youtube.com/watch?v=kfM-yu0iQBk
thumbnail: https://i.ytimg.com/vi/kfM-yu0iQBk/default.jpg
channel: "[[Freya Holm√©r]]"
date: 2024-07-22T16:11:29
published: 2021-02-27T02:03:04
duration: 13991
tags: 
done: false
cover: 
---
[[Read it Later|Read it Later]] [time:: "3h 53m 11s"]
# Shader Basics, Blending & Textures ‚Ä¢ Shaders for Game Devs [Part 1]
`````col
````col-md
flexGrow=1
===
![[Pasted image 20240722161149.jpg]]
````
````col-md
flexGrow=1
===
https://www.youtube.com/watch?v=kfM-yu0iQBk
<iframe width="400" height="210" src="https://www.youtube-nocookie.com/embed/kfM-yu0iQBk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
````
`````
Description:: Welcome to my three part lecture on shader coding for game devs üíñ I hope you'll find this useful in your game dev journey!

If you are enjoying this series, please consider supporting me on Patreon!
üß° https://www.patreon.com/acegikmo

00:00:00 - What are shaders?
00:03:00 - Case study/screenshots from FFXIV, Overwatch & more
00:37:42 - The Structure of a Shader
00:42:49 - Vertex shader
00:47:09 - Fragment shader
00:49:32 - Shader vs Material
00:51:29 - A first look at shader code
01:02:17 - Vertex Normals
01:06:17 - Interpolators
01:15:59 - Data types (fixed vs half vs float)
01:21:32 - Fragment shader output
01:24:31 - Swizzling
01:33:48 - Passing data from vertex shader to fragment shader
01:42:04 - Space transformation w. Matrices
01:47:07 - UV coordinates & manipulation
01:53:34 - Gradients
02:01:06 - Values outside of 0 to 1
02:09:20 - Triangle waves using math
02:12:04 - Preprocessor constants
02:25:28 - Pattern manipulation
02:31:48 - Blending Modes
02:39:42 - Depth buffer & depth testing (ZTest)
02:56:40 - Waves, ripples & vertex offsetting
03:12:07 - Textures
03:20:33 - World space coordinates
03:28:04 - Texture masking
03:37:33 - Isotropic mip maps
03:42:17 - Anisotropic mip maps
03:44:36 - Point vs bilinear vs trilinear filtering
03:49:54 - Final questions

Project Download & Assignments: https://docs.google.com/document/d/1h_7O9n5-q8Kb-rhnMJyF4Tab6i3lH97E4Ykn7tsP-zc

Originally streamed as a course for students at http://futuregames.se/, who were super kind to let me both stream this live as well as upload it here! so massive thanks to the people at FutureGames!!

üíñ Patreon ‚ù± https://www.patreon.com/acegikmo
üê¶ Twitter ‚ù± https://twitter.com/FreyaHolmer
üì∫ Twitch ‚ù± https://www.twitch.tv/acegikmo
üí¨ Discord ‚ù± https://discord.gg/v5VWuga
üå∏ Instagram ‚ù± https://instagram.com/freya_holmer

‚ú´ Video Production by Higher Vision:
‚û• https://twitter.com/HigherVision1
‚û§ Edited by Stelly: https://twitter.com/stelly47050876
# Transcript
[00:00](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=0) hello make a fire hello jamaica hello google drop a little average person i'm glad i got the average person in here that's neat okay uh i mentioned this 
[00:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10) last time uh when we did the math course that i'm gonna try to have this be a very practical and visual approach to what we're doing 
[00:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=18) in order to get into shaders as before feel free to ask questions at any moment i will be primarily reading the chat the future games private chat 
[00:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=28) one of the questions people have quite a lot is like what is a shader and some people ask the question of like do i need shaders in my project or should i use 
[00:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=37) shaders and the easy answer to that is that you kind of don't have a choice everything in a game is rendered with shaders there are some exceptions but these days 
[00:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=48) pretty much every game you play are like rendered with shaders absolutely everywhere so what is a shader uh you can think of a shader 
[00:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=57) as code running on your gpu that is kind of the most generalized way that i can think of defining shaders but in this case we're going to focus on shaders 
[01:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=67) that specifically render graphics onto your screen and quite often what you do is that you define a bunch of parameters like maybe the position of an object you have data 
[01:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=76) such as the a mesh you want to render maybe you want to render a cat in a game then you have a mesh of that cat and then you have 
[01:24](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=84) some way that defines the way that that surface should look and sometimes even move and that code is shader code so uh shaders are like because of the way they work is 
[01:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=97) that they are absolutely ubiquitous like absolutely everywhere in games you're gonna find many many different types of shaders that do all sorts of different effects 
[01:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=106) so i was thinking we could start by just like showing some examples of what that could look like in games right because i feel like it's not very tangible to not have 
[01:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=115) any like visual reference for this uh so shaders are more like normal maps rather than diffuse textures shaders are completely unrelated to textures 
[02:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=124) textures are input data that shaders can use if you want to but you don't have to so normal maps and diffuse textures are examples of data that we often use in shaders but shaders are more about 
[02:17](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=137) taking the information from textures or sometimes just other parameters or values or colors and then running a bunch of math on that and then 
[02:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=147) outputting it to your screen a diffuse texture for instance is usually something that contains the the color of the surface and if you want to render an object 
[02:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=157) where you have different colors on the surface and you want to define that using a texture you can do that if you want but you also don't have to use textures 
[02:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=165) in fact most of the work that i've done in the past like four years have almost entirely been textureless because i i don't know i like math and i 
[02:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=174) like doing things procedurally and most of the games that i do tend to have an art style that doesn't require that many textures so so last night i logged on to 
[03:02](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=182) final fantasy and i took a bunch of screenshots because i thought this might be a good case study let's actually open a game take a bunch of screenshots and then 
[03:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=190) just look at what is happening on the screen and how does this relate to shaders so let's let's jump into all of my screenshots i've been playing final 
[03:19](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=199) fantasy all um all holidays so i haven't been doing much else so of course i'm gonna continue doing things related to that um okay 
[03:29](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=209) so let's open up some examples here okay there we go so this is a screenshot from from final fantasy and final fantasy it's an mmo and mmos uh are 
[03:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=220) usually have a lot of like vfx and particle effects as you can see in this case uh the uh my character is doing an attack so there's this big 
[03:49](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=229) like ring thing happening uh there are impact effects on the screaming dog uh where you know you have some some wisps up here uh you can see that they're sort of 
[03:59](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=239) arranged in a circular pattern here as well uh there's another one here and another one here um and usually these 
[04:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=249) uh these types of things are a combination of particle effects and also meshes that have uh specialized shaders that run for like 
[04:19](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=259) that type of effect that you're trying to achieve um so for instance if we try to break this down and try to figure out like how how is this whole thing constructed 
[04:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=267) right i can try to think of okay so maybe this disc here uh this could be a single quad as in a mesh with um with two triangles right 
[04:39](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=279) uh and then on top of that you have like some sort of circular swirly uh vfx type of thing right so you render that on that quad and there are some like glowing vertical 
[04:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=291) stripes here this could either be a particle effect or like very small individual light strips it could also be a cylinder mesh that 
[05:02](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=302) simply has a texture that goes along the edges that gives us gives it all of those glowy stripes right same thing goes for the dog you can see 
[05:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=310) that there's uh all the rings here that could be a single quad that kind of encapsulates all of the effects there and then that has some sort of texture on it 
[05:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=320) um the the flare here very likely a particle probably also just a single quad with a flare texture on it uh same thing with this thing right here 
[05:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=330) and so forth and you can sort of like try to try to break vfx down in this way and try to figure out you know how is all of this constructed and what shaders allow you to do is 
[05:39](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=339) basically customize this in almost any way you want so rather than just having textures you can also animate these you can blend them with other things you can tell them 
[05:49](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=349) to render additively or they can multiply into the scene so there are many many different ways of doing this so here's another example where the different particles use 
[05:59](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=359) different blending modes so blending mode is just a way of like saying how should this combine with the background so i can actually show an example in 
[06:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=370) photoshop you can see that this one kind of adds a glow whenever i draw with this blending mode i can set a blending mode 
[06:19](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=379) to multiply and if we do that it's going to multiply in which in this case reduces the color values so it usually darkens right so so there are many many different ways 
[06:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=391) of blending it and then you also of course have the the regular blending mode which is usually just alpha blending or alpha compositing 
[06:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=398) we're kind of like rendering something on top of something else so these are very very distinct ways of rendering something on top of something else right um 
[06:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=408) so we can like try to look at this so so how do how can we break this down well we can see that there's like sort of an orange halo here right and that seems to darken the 
[06:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=418) background so we can presume that that is a multiplicative effect that is darkening that background then we can look at some of the other ones um it seems like the the black ones 
[07:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=429) here might not actually modify the background that much so they're probably alpha blended like the the blue one up there all the 
[07:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=438) gluey white ones here are almost certainly additive which means that they're going to brighten the background yeah so those are different blend modes when you say particle in this context 
[07:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=447) you're talking about engine stuff right the gpu shader code you see is a quad and it doesn't know what a particle and it's just a mesh uh pretty much yeah um so if we talk 
[07:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=456) about like individual shaders then shaders are generally what is dealing with each individual component of all of these things right 
[07:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=464) so if we want to count how many shaders we have here it is possible that this only has three shaders uh it could be that it's kind of hard to tell without 
[07:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=474) actually having the game at hand but it could be that there's one shader that deals with the multiply that's in the multiply blend mode 
[08:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=486) um and there could be another one that deals with additive and it could be another one that does uh alpha blending and then what can happen is that you use these 
[08:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=495) three shaders but you use them in different contexts and with different inputs we're going to get into that later um how the the structure of like shaders 
[08:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=502) versus materials and all that kind of going into too much detail here supposed to just quickly go through these okay what else here's another 
[08:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=510) interesting example uh so this one has a refraction in it uh refraction is usually when you take uh some usually background and then you distort 
[08:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=520) it so if you want to have like heat waves above a road or something uh then you can sometimes use refraction in order to distort some image underwater effects also use a lot of 
[08:49](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=529) distortion where you can see that the the character is here and then there's the distorted version here and it's a little hard to tell how it works when it's not in 
[08:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=537) motion and i didn't have time to record a thing in motion here's another example when you like kind of mash all of these together this 
[09:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=544) is more about vfx than it is about shaders i suppose but you can do a lot of like fancy effects if you if you combine a lot of things together 
[09:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=552) right um so in this case you can you can sort of trace out all the different disks you have here right there's one going uh here and there's a circular one going 
[09:23](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=563) there and you can see that with the combination of all of this you can achieve a lot of effects right um so if we try to break down the 
[09:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=570) shaders of these then again we're probably uh going to look at one additive shader here for anything that's glowing uh and then this looks like an alpha 
[09:39](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=579) blended one for stuff that shouldn't make things brighter this should just darken things right we want to blend toward the color of um that we have defined in in this 
[09:50](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=590) probably particle effect right another example of a lot of different planes uh this is also something that sort of goes outside of what you do in particle effects 
[09:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=598) uh if you talk about unity's particle effect system doing something like this is generally pretty hard because particle effects usually deal with a lot of particles naturally and they're 
[10:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=607) usually kind of scattered and in many different places but often you have cases like this where you have a very defined structure right um 
[10:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=616) where you want to draw these like strips on the ground with a lot of these symbols uh so these are likely two triangles right for each of these 
[10:23](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=623) uh i cannot draw a straight line anyway yeah so that's probably just a quad uh and then you have um another mesh that goes uh it's sort of like a the edges of a cube very likely that 
[10:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=636) goes along here uh you can sort of follow the shape i hope um and then of course you have everything is triangles so the mesh is going to be 
[10:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=644) triangulated like this so what what the shader can then do you know the shader has the mesh that is this inverted cube with only the walls right 
[10:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=654) and then what you can do then in the shader is that you have lots of textures you can combine in different ways um so you can see that there's this uh pink smoke like effects 
[11:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=665) uh so so this is very likely a texture that is mapped along this whole shape there are some some like multiply effects here that like dark in the background 
[11:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=675) um that could be part of another render pass of this cube i'm not sure um and so forth um so so usually this kind of goes outside 
[11:25](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=685) of what you can do with particle effects this is more you know you have a mesh and then you want to make it look a very very specific 
[11:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=692) magical way um and that is something you can do with shaders okay should i go through more examples or is it boring you at this point i probably took too many screenshots 
[11:41](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=701) same thing here uh it's a big brown texture um a lot of like additive glowy effects there are these little daggers pointing into the ground ground and 
[11:50](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=710) all of these are probably also just simple quads and stuff right this became a vfx course now it's not about shaders anymore it's about vfx oh here's a good one you can even use 
[12:00](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=720) traders and ui so this is an example of a progress bar that sort of has this mask on top of it in order to have all of these symbols but what's happening underneath these 
[12:11](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=731) symbols is that there's a progress bar that's going to render inside of these you can see that it's halfway filled here where it's sort of going up to this 
[12:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=740) point so so this is also a very good use case for shaders um you can you can make a single shader that 
[12:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=748) you know renders this thing and then you have input data that says how like what is the percentage of fill on this bar right and then using that you can then 
[12:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=758) just define exactly how you want this to look depending on how much um how much you've stored in this bar right same thing goes for like a lot of mmos 
[12:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=766) have like markings on their icons uh so these little dashes around the edge here um they are also animated and move around in a circle you could do that 
[12:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=775) using a shader um there are lots like circular progress bars so you can also define in the shader um or you can do it with sprite sheets 
[13:02](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=782) usually makes things easier than custom shaders for everything here's my render pipeline related one um so shadows if you want to make shadows in a game 
[13:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=792) that also requires a lot of processing on the gpu because quite often your gpu needs information about everything in the world in order to cast shadows 
[13:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=802) like this right um so if we look at the if you look at the scene um most of the background is pretty well lit there are some shadows here in the 
[13:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=810) background that are cast here but there's a building here that is casting this uh pretty complex shadow right because it's following uh 
[13:39](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=819) following the shape of the the edge of the roof of this building right and it also like uh casts realistically on top of all of these objects 
[13:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=828) so that continues there and then even for dynamic shadows for the character there's shadows going underneath there shadows going across here 
[13:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=836) um going all the way down there right and this is another process that you tend to do on the gpu and there are many different ways of doing shadows but it's kind of 
[14:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=845) interesting that like some of the techniques you use to cast shadows is that you kind of render the scene from the point of view of the light source 
[14:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=854) and you only render how far away geometry is uh and then you can use that information in your usual frame that you're rendering here in the game 
[14:23](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=863) uh to know uh whether or not shadow or light is gonna hit a certain point or not right here's another example the skin is a pretty difficult thing to 
[14:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=872) render it turns out um skin has a lot of properties that generally most like solid objects in the world don't have 
[14:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=880) um so so one thing that you might notice when skin is rendered in some game uh is that usually there's some highlight where the light source is hitting right 
[14:49](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=889) uh the this is the highlight on the the cheek and then you can see that it sort of fades to shadow in this direction right um and then you have a shadow line here 
[15:00](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=900) right uh so one thing that skin has which is a very like specialized thing uh is usually called subsurface scattering subsurface scattering means that 
[15:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=909) light sort of enters something so if you have a surface you have light rays coming in in many cases if it's a perfect mirror light would 
[15:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=918) just bounce off of it right but in some cases light can actually enter and then the light can scatter around inside of some surface and then hop out 
[15:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=928) somewhere else uh what happens is that usually some wavelengths are absorbed when this happens so it could be that you have 
[15:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=938) white light coming in uh but then once it starts to scatter inside of the skin some wavelengths are absorbed um and you you can get a more red tinted light coming out of it uh because 
[15:50](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=950) the greens and the blues have been absorbed so mostly red is coming out so quite often with skin is that you you get this red tinted shade here that happens in the 
[16:00](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=960) transition where you get less light but then the scattered light keeps spreading out of that um you don't need to know how to do all 
[16:08](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=968) of these things i'm kind of just going through of like what you can do with shaders and some examples uh from in this case from final fantasy and then 
[16:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=976) there are all sorts of properties of all of these surfaces right um you the uh for instance the lower lip has a very glossy highlight here right 
[16:25](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=985) uh but the cheeks don't there's not a glossy highlight here um or on the nose or like nothing like that right there they're pretty matte um so all of these things are things you 
[16:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=995) need to define in the shader uh where do we want things to be glossy where do we want things to be matte uh where do we want to have subsurface scattering and so forth 
[16:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1004) um let's see what else uh oh hair rendering is surprisingly difficult but i don't know if we should get into all of the details of that here's another good thing to talk about 
[16:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1015) um someone mentioned normal maps before normal maps are kind of a way to add more geometry data or what looks like geometry data without actually adding geometry 
[17:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1029) uh so quite often you know you're making mesh with meshes with triangles so we can try to like sort of work out what the mesh looks like here this is a pretty low poly mesh right you 
[17:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1040) can see that it's very jagged but the internals of it it looks pretty detailed right it looks like a pretty smooth curved surface all of these intricate 
[17:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1048) details look really nice but what the geometry likely looks like if i were to guess is that i'll probably have a very very simple 
[17:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1060) structure actually i could see that one now i'm guessing it would be something like this so it's sort of just like a very simple low low poly cone 
[17:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1071) but with certain textures you can make a normal map which encodes data about the direction that a surface is pointing and with that data we can make it look 
[18:02](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1082) as if it's being shaded as if there's geometry there same thing goes with this uh this doesn't actually exist in the triangle data 
[18:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1090) but if we have that encoded into a texture we can then use that texture in order to get more detail out of it instead of just adding geometry all the time right 
[18:19](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1099) especially in like an mmo where you're gonna have to uh you're gonna have to have like a lot of characters in one place and adding geometry detail that's like 
[18:29](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1109) super super high poly to that it's not going to work out well right so you need some shortcuts to add more detail where there is none right uh so we're going to do normal maps 
[18:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1118) probably on thursday i think depending on how far we go all right let's see let's switch game overwatch what a what a game so we can see sort of 
[18:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1126) the same concepts here like regardless of what game we're looking at we can almost always just take a screenshot and then sort of break down what's happening in the frame 
[18:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1134) um so overwatch is kind of interesting uh in many ways one thing that blizzard tend to do in their games is they have a lot of like 
[19:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1141) specialized shaders in their ui um so this glow for instance is sort of like an additive particle effect but it's in your ui instead of in the world and then 
[19:11](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1151) obviously in the world there are tons and tons of different particle effects uh you have like a roadhog's gun uh you've got like an additive thing here um and i can't draw for some reason 
[19:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1162) oh i'm drawing underneath great and then you have the reinhardt's barrier this one looks like it's very glowy it could be additively rendered and then you have some refraction here again you 
[19:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1171) can see that there's uh like a distortion bubble here might be hard to tell on stream um but you can see that it distorts this uh path here 
[19:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1180) there's a smoke trail coming here that also gets a little distorted um uh what else we have uh tracer just did a blink thing maybe reverse i don't know which 
[19:52](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1192) effect this is this is probably the teleportation thing um so you can see that tracer is rendered completely differently here right 
[20:00](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1200) um so very likely tracer's shader has just been completely swapped to some other shader right everybody else is rendered like with their normal textures and whatnot 
[20:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1209) uh but tracer in this case um has an entirely different one and the this particular type of shader is usually called a fresnel shader 
[20:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1220) fresnel is a an absolutely ubiquitous term either you're going to hear about too much uh f-r-e-s-n-e-l because yay french names um fresnel 
[20:33](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1233) so what renewal basically means that um as something is starting to face away from you uh you get a stronger light uh so you can see that the edges 
[20:42](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1242) are kind of lit up here right uh but the middle is not lit up so it's almost an outline effect uh but it's not actually an outline effect and it's kind of important to know the 
[20:52](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1252) difference between the two all right another example for now roadhog in this case is being frozen um and it's probably a little bit more visible here to see 
[21:02](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1262) how it works so you can see that if you look at his hand for instance stuff that is kind of directly facing the camera in which case like this part of the thumb does not have this 
[21:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1273) glowy effect it only starts happening for surfaces that are facing away from you right so the roadhog's hook here for instance is also 
[21:23](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1283) facing away from you more so than this part of the thumb and therefore it's brighter right and this part is has a very very steep angle so this whole thing is very bright 
[21:33](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1293) um so so this is a very useful simple way of getting a sort of like outline effect highlighting objects um and so forth another one winston's shield similar 
[21:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1305) thing um this reader also has some like extra features for um because this is a spherical bubble uh but it can intersect with the world in 
[21:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1314) different places so it intersects with the ground here and then it makes it so that there's a bit of a light going around that edge uh so it 
[22:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1323) kind of follows around the whole bubble uh it also intersects with the world up here right so even though it's intersecting with a pretty complicated geometry here 
[22:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1332) um it can still maintain to do this like whole outline thing yeah usually that's done with like ducks hackery and whatnot but different i love relations with rim 
[22:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1340) light or am i confusing them with each other um they are usually related but they're not the same thing there are all sorts of things that are 
[22:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1347) called fresnel if you start reading up on like physically based shading you're going to find the word fresnel in terms of like physical light 
[22:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1355) propagation which is slightly different than the artistic usage of just a fresnel shader um yeah but but the the idea is that as the angle towards some surface versus 
[22:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1368) the camera is very low something happens right and we're going to make a pronunciator later so now we can see it in action if you want to here's a screenshot from demon souls 
[22:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1378) um and you might tell that there's a bit of a highlight effect on the character this too is for now everything is for now fresnel is everywhere uh no matter what game you're getting 
[23:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1387) into there's there's going to be fresnel somewhere exactly the same effect you get like a glow around the edges and as the surfaces are pointing toward you that 
[23:17](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1397) glow sort of disappears and it fades to darkness um yeah so it's exactly exact same principle um it is important to note though that 
[23:25](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1405) fresnel is kind of only like it works best for surfaces that have uh relatively smooth surfaces as soon as things get sharp you don't really get the same outline effect 
[23:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1416) as you can see the shield here doesn't actually really have that type of highlight uh not even close compared to like the like around the knees here 
[23:43](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1423) right um so so they're a little bit separate but it's just very very easy hack to add to your stuff and it also looks a little different 
[23:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1431) than an actual outline effect this is the game return of the obradin um very very different uses of usage of shaders we're being sort of looking at 
[24:00](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1440) more vfx and realistic stuff uh this is another um game that is heavily using shaders uh but for an entirely different artistic purpose right 
[24:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1449) uh so the return of oberdin um is a game that is only using two colors uh there's uh well it's not exactly black but it's pretty much just black and white 
[24:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1458) and then in order to express shading uh they use dithering in in their game so um yeah so see like this is something that you can do with shaders too 
[24:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1467) and like this is like perfect for shaders because uh they deal with these types of like graphical things and then you can yeah do all sorts of artistic effects 
[24:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1476) like this another example is of something less realistic is kentucky route zero this is one of my favorite point-and-click games it's super super 
[24:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1486) nice and atmospheric kentucky red zero also has a a very very like um minimalistic art style but even though it's very minimalistic there are lots of places where they use shaders for 
[24:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1497) artistic effect right um so in this case you can see that they're they're playing a lot with depth in this one um 
[25:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1504) because if you look at the trees here the bird is in front of these trees but the fog implies that these parts are in the background um so this is a like very like it's a 
[25:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1514) trippy effect it's a trippy game uh that is that employs all sorts of like graphical things to um to achieve their like artistic vision right 
[25:23](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1523) and you wouldn't be able to do this if you were just using like unity's built-in shaders right um so really what shaders are about is allowing you to expand your visual 
[25:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1534) horizons right i thought that was sorting of the sprites all of this is dynamic and so if you move the camera and the geometry it's kind of difficult 
[25:42](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1542) to do this without like coding that into the shaders but maybe you can do it with just sorting as well but regardless setting shorting sorting 
[25:49](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1549) on something is dealing with the graphical aspects of this which is dealing with shaders right that was a very long just walk through of random [¬†__¬†] in games oh i actually 
[26:00](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1560) had a few like separate examples uh here's an example from from a game that i worked on uh made in my studio neat corp um so this is the portal locomotion system 
[26:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1573) in budget cuts so in this case this one has a very very specialized shader for dealing with opening up this portal right 
[26:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1582) so you use this portal to move between locations and rooms that's pretty much what this does so you can see that you open up a portal into a different room and then this 
[26:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1592) renders into that portal that's sitting in your hand uh and then you can still see anything outside of that right and yes this is a vr game and then when you 
[26:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1600) teleport this bubble sort of expands and encapsulates your entire field of view and then once it's encapsulated your field of view you're standing at the new location and we 
[26:50](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1610) wanted this to of course be like a completely seamless experience uh so we didn't want to have any jarring like flashes happening or um you know we didn't want to 
[26:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1618) approximate this either we wanted it to be uh look exactly like you're just like smoothly moving to the new location right is it a second camera with a 
[27:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1626) render texture it used to be uh but it's not anymore because turns out having a like like rendering things in vr you generally have to do things very high 
[27:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1636) resolution because you have uh you need a lot of pixels for it to look good because you have a very wide field of view when you're wearing a vr headset so you need a lot of pixels 
[27:24](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1644) it's usually a higher resolution than you know 1080p or whatever um and if you want to have another render texture for the portal 
[27:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1651) that usually means that you're going to have another full screen render texture which is a lot of memory especially if you want to like target the lower end platforms 
[27:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1660) here's a very simple example uh this is from another game i'm working on called flowstrom uh with this little rocket here so so this is um another vfx shader uh it's uh this 
[27:50](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1670) rocket flame is a single quad it's it's two triangles and then everything else is done in the shader so you can see that it's sort of bending 
[27:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1678) when the rocket turns it changes color when you stop or start accelerating um yeah and then the little flakes that is a particle effect but everything else 
[28:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1687) is done in the in the shader itself a water shader i made for um another game at nicor so that game is very very stylized so in this case i wasn't like aiming for 
[28:17](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1697) realistic water whatsoever but i wanted it to look really colorful and um yeah very lush and pleasant to look at so then you tend to want to get these like 
[28:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1708) you want to add a little foam ridge along the edge you want to have some cute specular highlights and you want to have this gradient that goes from like um 
[28:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1715) tropical cyan and then down to the deeper blues right here is is not my shader this is from uncharted uh uncharted and then the team working 
[28:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1724) on uncharted have like some of the best technical artists out there so usually if you want to look at really really really high-end 
[28:52](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1732) uh like aaa shaders they do really good work there um so so this is a lot of things are happening here of course but the surface of the water is going to 
[29:00](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1740) be one shader you have some particle effects for all the smoke there um there's even a rainbow like there are lots of things happening uh but but this is again stuff you can 
[29:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1749) do with shaders oh and the rocks as well we haven't looked at boring objects but all the boring objects have shaders too um i'm mostly talking about the more like 
[29:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1758) exceptional cases so you can't really do um you know only using the built-in shaders right um okay 
[29:29](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1769) all right any questions so far i guess there's nothing to ask about i just mentioned that cheaters exist in games uh does the portal shader have a field 
[29:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1777) for position of the current portal and then i just render stuff from that position in a circular viewport the way that it works right now is a little complicated to explain 
[29:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1785) um but uh but generally the easiest way to explain it is you have a player position right you have the cameras that are rendering for the player camera where 
[29:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1795) the head of the player is because it's vr um so you have the camera for your head and then once you place the teleportation beacon somewhere 
[30:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1804) we create another set of cameras that mirror like where your head would be if you were to teleport right so then we have two sets of 
[30:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1813) cameras and then what we do is that we render the first set of cameras and then we do some depth buffer hackery and then we render the second ones 
[30:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1822) um on top of that so there's no render texture it's all just the frame buffer but it ends up just working out um 
[30:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1832) has a lot of weird side effects though because depth buffer hackery kind of breaks a lot of things uh but it worked out how often does someone need to code a shader compared to an artist making a 
[30:42](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1842) shader using nodes um that's a good question um it's hard to like distinguish between the two because quite often you can have coders just making it using nodes as 
[30:53](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1853) well uh right now whether or not you should make things with a node-based editor versus writing things by hand and unity at least it's more determined 
[31:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1861) about like determine are based on whether or not you're using um specific render pipelines if you use the built-in render pipeline you're most likely going to write 
[31:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1869) shaders by hand or use like a third-party shader editor like my old shader forge or amplify shader editor if you're using the unity's new urp and 
[31:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1880) hdrp render pipelines then you're probably going to use shadeograph for those right but but it kind of depends i mean if you have a team of a lot of artists that 
[31:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1891) can make shaders and gnome-based editors then that might be a really good advantage because quite often shaders live in this sort of weird territory 
[31:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1900) of it's very technical and yet it's also very artistic and visual right it feels like the most low-level front-end code you're ever going to do because 
[31:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1911) you're like very very much doing like extremely low level operations and yet it's something that is like directly going to be visible to players usually not always but usually are there certain 
[32:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1921) tools for making maps like normal or displacement maps or do you draw them by hand there are many different ways of doing them you can either generate them you can either sculpt them if you're 
[32:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1930) using something like zbrush usually you sculpt a model and then you can export a normal map from that and then you you can have a low poly version of your mesh that then uses the 
[32:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1940) high polish normal map um that's a very very common workflow for like aaa style realistic graphics and whatnot um you can also do 3d scanning you can 
[32:29](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1949) you can literally do photogrammetry scanning of different surfaces or even entire models and then export like texture maps from that what can you use to generate them 
[32:39](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1959) you know i haven't generated them for a very long time i don't know what generally if you take like a color texture and generate a normal map 
[32:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1967) out of that you usually get very bad normal maps i'm sure you can find tools online for this there used to be one a really long time ago called crazy 
[32:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1976) bump um i think x normal is something that artists use a lot even though x normal looks like it's from years ago i don't even know how many 
[33:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1985) decades ago it looks like xnormal has a very wind amp aesthetic um anyway x normal is very very commonly used for baking normals like taking a high poly model generating 
[33:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=1995) a normal map and then using it on a low poly model substance painter is a pretty good program for stuff like that yeah so they're a bunch of like 
[33:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2002) procedurally or like substance designer is a really good uh tool for generating textures um it's really really neat you can do all sorts of like procedurally generated stuff 
[33:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2012) then export you know all the maps you want from that like um height maps normal maps and specular maps gloss maps metalness maps and whatever 
[33:41](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2021) um oh and albedo maps um they're all sorts of like procedural tools like that there's also like you mentioned substance painter which as far as i know 
[33:50](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2030) i haven't used it that much but um i'm pretty sure it's a tool where you can sort of draw on the mesh and then that you can draw directly into the texture 
[33:59](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2039) on the mesh itself rather than using a flat texture right and then it has all sorts of like procedural things if you want to like add weathering to it or add rust to some 
[34:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2049) object or whatever it's very easy to do that using um the tools that substance have uh artists often can't or don't make shaders unless they're technical artists 
[34:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2058) right um it's a matter of definition i suppose but usually uh the capital a artists who just do 3d modeling or 2d art generally don't do shaders 
[34:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2067) um quite often there's you know a specific role in game development where someone is a technical artist and the technical artist is then responsible for creating those shaders 
[34:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2078) um and then usually you need to make sure that communication is good because not all technical artists are good at art um so sometimes you need to have like an 
[34:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2086) art director or even other artists to like guide them like exactly what they want to want to achieve right how do you learn about the various types 
[34:52](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2092) of shaders like where does one even encounter the fresnel thing in the first place uh good question um i guess a lot of like looking at 
[35:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2101) existing games and googling for how to achieve certain effects i don't really know how i learned about it the first time probably it was my teacher a really long 
[35:11](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2111) time ago yeah i don't know listen to me there you go that's how you encounter these effects you're you're in it right now this is the way but you can probably 
[35:19](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2119) find like some website that has like a repository of like different shader effects and whatnot fresnel happens all around you irl constantly yes 
[35:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2127) although yeah it depends on what type of renault you're talking about but the the light effect of the fresnel effect yes that happens a lot i don't know if we can if it's possible 
[35:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2137) to show it on stream okay maybe this thing maybe okay you might be able to see that the the top of the outer edge of this thing right there has a bit of a 
[35:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2148) glow to it right um and the idea is basically that almost any surface when you get to a low angle enough oh actually you can't see my fingers in a reflection 
[35:59](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2159) on this object right but if you go really low you can see some reflections off of this right uh so the idea is that if you have a very very very steep angle 
[36:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2169) looking at a surface it becomes more reflective um that's the more um scientific light version of the fresnel effect uh which you might want to 
[36:19](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2179) separate from the more like uh unrealistic um glowy fresnel effect that people usually add to like highlight objects and whatever 
[36:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2188) reflections on a water surface might be a good example for fresnel yeah water is a pretty good example of that um usually pretty hard to find good 
[36:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2197) pictures that shows you both the transparent part and the reflective part um i had one in the presentation at one point i mostly find like fake ones and 
[36:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2206) renders that are like not super good here's a pretty good example um so it's kind of difficult to see here probably on stream but it's way 
[36:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2217) more transparent here right you can sort of see the stuff underwater um but then as you go to a more like grazing angle like a very very sharp 
[37:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2226) angle um there there's like a very very like mirror like reflections right um so that's the fresnel effect in action uh 
[37:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2235) in this case there's sort of a trade-off of like you know how much of the light do you see that's reflected off of it versus the light that's coming out from 
[37:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2242) underneath it right so now we mostly talked about like what you can do with shaders some uh vague effects of like uh you know what what you can do in like 
[37:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2252) different types of games and what some effects are called but we haven't actually gone into like how to make shaders this is all very like theoretical so let's get 
[37:39](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2259) closer to the the practical reality of making shaders in unity so usually there's a bit of a like terminology mess when it comes to shaders um because 
[37:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2268) when someone says a shader that can mean many many different things unfortunately um so so i'm going to try to like try to break this down 
[37:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2277) the structure of a shader works um so we can start with a the dot shader file right so we have a shader here so now we've got the unity file of 
[38:08](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2288) the shader so what does this contain let's break this down um a shader has properties properties are 
[38:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2296) basically it's basically a set of input data so uh this could be like uh colors uh it could be just values that you use for like um 
[38:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2307) maybe it's a number for the amount of health you have and then you want to render a health bar using that value this could be textures and then indirectly you don't pass this 
[38:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2320) with the property but indirectly you also pass the mesh that you're going to use right so the mesh that's going to be rendered is usually passed into it 
[38:50](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2330) and then you also have the matrix for that mesh not always but usually so the matrix contains the transform data of where it is how it's rotated how it's 
[39:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2341) scaled all that stuff right so these would be actual properties you pass in and these are kind of implicitly passed in from you know whatever object you have in the game right 
[39:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2350) right so we have a shader a shader file the shader file contains properties all right what else uh so so properties is just the input data but not the shader itself isn't here yet so 
[39:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2361) then the next level uh is a sub shader so a sub shader you could just call it a shader it's kind of confusing but the way that things are set up in unity at least is 
[39:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2372) that you can have multiple sub shaders in a single shader file uh so a use case for this is that you might have a sub shader that is meant to be a little bit more 
[39:42](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2382) optimized um to run on like low end platforms so if you have multiple sub shaders you can make it pick the one that's appropriate for your 
[39:50](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2390) uh current situation right but for our purposes we're not going to make multiple sub shaders so you might as well just consider it a shader um 
[39:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2398) the subshader itself contains something called a pass and this is a render pass or a draw i don't really know what you want to call it but we can just call it a pass 
[40:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2407) and subshaders can contain multiple passes so you can have multiple passes in here there are a lot lots of shaders that are not multiple passes usually you do that 
[40:17](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2417) if you're doing like certain types of lighting you sometimes want to have multiple passes or very very specialized vfx uh but usually 
[40:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2426) you just have one pass um so you should usually it's a relatively straightforward path going from you know shader sub shader pass and then you can start writing your shader code 
[40:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2435) so inside of the pass this is where the actual shader code is happening you can break a path down into many many different types of shaders but usually what you're going to 
[40:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2446) be using is a vertex shader and a fragment shader the fragment shader is sometimes called a pixel shader uh but it's a bit of a misnomer so the fragment shader is the 
[40:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2458) the technically correct one if you're going to search around for this you're going to find people calling it the pixel shader oh yeah so so this is the kind of the 
[41:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2465) basic structure of a shader file in unity um so if you if you're wondering like where is the shader code here uh then what this is is that 
[41:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2476) this part the vertex shader and the fragment shader that is the part that is going to be written in the shader language hlsl i think it's 
[41:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2487) high-level shading language or something like that so so that's the actual shader code right everything outside of that as soon as 
[41:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2494) you get into the the passes the sub shader the properties all of this is kind of unity's own syntax for like defining where should this happen in the render 
[41:42](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2502) pipeline um should this have some sort of properties some input data and all that stuff all of that is called shader lab so sometimes it's useful to distinguish 
[41:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2511) between shader lab and hlsl if you want to like um sorry about my bad handwriting so all of this is pretty much shader lab like all of this the part in white 
[42:02](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2522) okay so so the actual shader code you're going to be doing is a very specific part of the shader the red part here is the fun part the white part is the boring part because 
[42:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2532) the boring part this is mostly about figuring out how the heck do shaders work in unity how do i access x y and z stuff and you know there's usually 
[42:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2540) a lot of like boilerplate involved here but this is pretty much the basic structure of a shader okay so what do what do all of these things do so like 
[42:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2548) what is the difference between the vertex shader and the fragment shader and what are the used form all right so let's let's see if we can break it down so we have 
[42:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2556) a we have all of these properties right we have the colors the values uh the textures the mesh and the positioning data so all of this is going to be an input 
[42:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2565) to a shader code that is then going to run right let's start with the vertex shader let's go here we go vertex shader perfect 
[42:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2574) uh vertex shader basically takes all the vertices of your mesh right because when you're rendering something in a game um you usually do that with a mesh and 
[43:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2585) meshes are built out of vertices and triangles right so you have all of this data that is coming into the shader 
[43:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2594) uh you have some mesh maybe it's a cube uh maybe it's an entire character it could be many many different things but the point is whatever you render in a vertex 
[43:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2602) shader is going to be composed of lots of vertices right um so what the vertex shader does is you it's kind of like a for each loop over all of the vertices that you have 
[43:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2615) and then you can access data from that from all of those vertices so so you can think of the vertex shader as a for each vertex right and then 
[43:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2626) all of your vertex shader code lives here so you do you you can define all of these operations on every vertex in most cases what you want to do in the 
[43:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2637) vertex shader is that you want to put these vertices at some place in the world right so if you have an object like 
[44:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2646) i don't know let's say you have a cube right this is not a very good cube you want to put this somewhere in the world uh but one problem is that the vertex shader doesn't really want 
[44:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2655) you to put things in world space um and not in local space either and not even in view space the vertex shader wants you to say where are 
[44:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2668) these vertices going to be in what's called clip space and clip space is kind of like a normalized space from negative one to one 
[44:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2676) uh inside of your your current view or render target um so usually it's kind of a like weird transformation where you jump between like three different matrices 
[44:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2686) but but generally there's a very very simple way that you do that you basically take the local space coordinate of all of the vertices and then you 
[44:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2695) transform that using what's called an mvp matrix to to then convert it to clip space uh and then you're kind of done right um but what you can do in here is that you 
[45:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2706) you can you can modify the vertices if you want to but yeah the usual case is that you don't modify them but you can do that if you want that's the vertex shader what was 
[45:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2714) tangent space now again uh we're going to talk more about that later i could go into it now if you want to but i first want to talk about the the 
[45:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2721) general structure of the shader okay so we got the vertex shader here uh so i'm going to try to do this chronologically all right oh like someone is mentioning 
[45:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2731) the vertex shader is often used to do like um animating water or um doing stuff like uh leaves that sway or like grass that 
[45:39](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2739) can sway in the wind um because then what you usually do is that you define some math in the vertex shader that makes these move 
[45:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2747) in a certain way right because you can set the position to anything right it doesn't have to be where the object is even right or the acid shader yes if you want to do 
[45:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2756) the the acid minecraft one you would put these things in some wild location that would make it look trippy right okay so you got the vertex shader um 
[46:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2766) where you are going through all of the vertices and you can do whatever you want there right as long as it's a per vertex thing 
[46:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2774) should you manipulate vertex uv coordinates in the vertical shader generally yes you can do it in both the vertices and the fragment shader but it depends 
[46:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2781) like can you do it in the vertex shader then almost always do it in the vertex shader if you can't you have to do it in the fragmentator right 
[46:29](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2789) okay so we got the vertex shader and now we're moving on to the next stage there is some internal magic that happens here on the gpu um so what's happening here is a lot of 
[46:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2800) stuff related to the depth buffer uh it's gonna do like a rasterization step where uh you know it knows the position of all the the vertices 
[46:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2808) and then it's gonna try to translate that into you know what pixels go where um according to where you place them um and so forth right uh so so there there's a lot of like internal stuff 
[47:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2821) happening between these things okay but after that's done um you can now go back to your code where you can start defining things on your own so now we get to the 
[47:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2830) fragment shader okay um so now in the fragment shader uh just like the vertex shader was kind of like a for each loop over every vertex uh the fragment shader 
[47:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2841) is a for each loop over every fragment and the reason it's called fragment and not a pixel is because pixel is usually one to one corresponding to a pixel on your screen 
[47:33](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2853) uh but in shaders that's not always the case so usually use the word fragment um but in most cases it's it's kind of the same thing as pixels right so it's sort of like uh for 
[47:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2865) each pixel inside of all the geometry that we're now rendering we're gonna run some code okay so the fragment shader um basically all you do 
[47:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2875) is you set the color of every pixel so what color is this going to be well that's that's up to the fragment shader uh maybe it's going to be red maybe it's going to be green maybe it's going to be 
[48:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2887) something else entirely right so the fragment shader basically iterates through all of the fragments or pixels that are going to be rendered and you can write 
[48:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2896) code to define exactly how that should look and there are all sorts of ways of doing that this is where like everything sort of happens where you can make it look 
[48:24](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2904) exactly the way you want but yeah this is the basic structure and this is usually the limitations you're also working under right because this is a relatively 
[48:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2914) limited structure where you need to uh do things one at a time right the vertex shader always happens before the fragment shader and so forth um and there's not really any uh 
[48:43](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2923) communication in two ways like back and forth between these and there's only a one-way communication from you can pass information from the vertex shader to 
[48:52](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2932) the fragment shader but not vice versa okay so the fragmentator you specify color gloss in a specular phenol etc vertex shader is only the shape of the object 
[49:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2941) yeah so the vertex shader all you do there is either set the position of vertices or you pass data to the fragment shader that's kind of it that's all you do 
[49:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2952) there but sometimes you want to have very very specific data that you have like pre-processed in some way before you pass it to the fragment 
[49:19](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2959) shader a good example is if you want to manipulate uv coordinates but we're going to get into that later yeah so basically um this is setting the pixel color 
[49:29](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2969) and that's it it literally returns a color oh i didn't distinguish between shaders and materials that's also important let's do that 
[49:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2976) so generally what we're talking about here this whole thing is the code that you define in the vertex shader and the fragment shader which lives 
[49:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2984) in a pass which lives in a sub shader which lives in a shader file so there's there's a lot of like nested things initiator so sometimes it's good to like make sure 
[49:53](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=2993) you keep track of all of this stuff you can think of all of these things as input data to rendering your object right uh the green ones up here 
[50:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3003) uh these are usually called properties uh they are properties that you can configure uh before you're rendering your objects and then there's some extra data for you 
[50:11](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3011) know the the mesh you're gonna render and the uh the transform of that mesh itself uh these things are usually like automatically supplied by your mesh 
[50:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3020) renderer components um but the these properties you have to define yourself and usually the way that you define these properties 
[50:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3030) is using a material so the material itself contains ex like explicit values for all of these different parameters that we can input to our 
[50:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3040) shader and the material also has a reference to the shader so you can never quote unquote add a shader to an object in unity in unity you apply a 
[50:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3051) material to an object and that material then has a reference to the shader itself right so you can sort of think of materials as pre-configured parameters to be used 
[51:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3064) when rendering something with a shader right so to clarify you can have multiple materials that all use the same shader but they have different input data which is 
[51:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3073) very very common um say you have a shader that renders that has a single property of a color then you might have you know two materials that both use the 
[51:23](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3083) same shader but one of them has the color red the other one has the color blue or whatever right so let's look at shader code let's get a little bit more practical 
[51:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3094) so there are many different types of shaders you can create in unity um since this is a course for coders i want to start with sort of the simplest most low level thing 
[51:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3105) um because i think it's good to get a grasp of like how shaders are structured and i think the best way of doing that is to use the unlit shaders in unity there are many many different types of 
[51:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3116) shaders especially if you go into the different render pipelines and if you use shadeograph and so forth but for now we're just going to make the simplest 
[52:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3123) outlet shader all right i don't know what to call this shader one there we go perfect name uh for a shader file uh okay so let's see 
[52:17](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3137) all right there we go here's this here's the default shader um and i'm gonna fix all these brackets because they annoy me um 
[52:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3148) all right so you can see that we got the the shader itself and then we have the properties so again the properties this is the input data excluding 
[52:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3157) the mesh and like maybe lighting information and all of that stuff that unity automatically supplies um so that's kind of your own defined input data 
[52:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3167) um the then you got the subshader itself the subshader contains the pass and then the pass contains your actual shader code so anything inside of the cg program 
[53:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3181) and ncg uh that's part of the shader code um it says cg unity is practically hlsl but you can call it cg as well if you want to 
[53:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3192) um okay uh let's see i'm just gonna fix some more brackets because i don't like these brackets um all right we can go through this line 
[53:23](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3203) by line if you want to so uh both the sub shader and the pass has a bunch of tags and things you can like specify in order to define how this object should render 
[53:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3215) uh so the sub shader has stuff when it comes to like sorting um you know is this object opaque is it transparent i do want to change the queue of this so that 
[53:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3224) it renders before or after some other shader that's the type of stuff you set in the sub shader in the past you set the more like explicit rendering stuff for 
[53:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3234) this render pass itself such as the blending mode um you can set the stencil properties and so forth as a sub shader usually it's more render 
[54:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3243) pipeline related and pass is more like the the graphics related stuff for this specific render pass lot 100 is a specific thing that you can 
[54:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3253) use to i think you can set a lot level of an object and then it will pick different sub shaders based on what you set lot to 
[54:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3262) um i have personally never ever used this so we're gonna delete that uh no more lawd all right uh cj program so this is where the the shader code starts 
[54:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3271) uh and then we have uh pragma vertex vert pragma fragment frag this is just a way of telling the compiler uh what function is the 
[54:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3280) vertex shader and what function is the fragment shader so basically we're saying that we want our vertex shader to be the function that is called vert 
[54:50](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3290) right which is this one down here uh and we want the the function called fragment to be our fragmentator so this is kind of just like pointing to the name of these functions to say that 
[54:59](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3299) this is the uh this is the functions we're gonna use for for these two um shaders right we're going to ignore fog so i'm just going to delete 
[55:08](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3308) everything related to fog that's gone uh include unity cg.ct inc um this literally takes a code from a different file and pastes it into your shader 
[55:19](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3319) um so unity cg.cg inc is a file containing a lot of the unity specific things that you might want to use in order to like do things more efficiently there 
[55:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3331) are lots of like built-in functions there it's a very useful one to include um so um yeah you pretty much always have that 
[55:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3338) there you can also have your own things included if you want to include a math library or something i don't have a math library for shaders to pitch god damn it 
[55:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3345) okay so now we're now we're on to to the bar specific shader code stuff so app data i hate this name i think app data is a terrible name for this structure 
[55:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3355) uh so we're going to rename this uh mesh data there we go i'm going to use capital m uh you don't have to follow along by the way uh like you don't have 
[56:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3364) to write the same things that i'm doing um just a heads up so i might go a little quickly because i'm not like expecting you to do the same thing at the same time 
[56:11](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3371) all right so i'm gonna call this mesh data this is a structure that we're gonna run into later um so this is a bit of a weird order for all of these things i might 
[56:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3382) move things around a little bit um okay um so so then you can define variables for your stuff i think they're sometimes called uniforms 
[56:33](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3393) but basically if you have some property in this case it's a texture called maintex you also need to have a variable to define along with it it's a bit boiler 
[56:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3404) platy and annoying and texture is a little bit uh texture is a little bit complicated so we're actually actually going to delete that we're not going to 
[56:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3411) use textures so i'm going to replace that so let's say we want to have a let's say you want to have a value just a single float value right 
[57:00](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3420) um so let's see i always forget the syntax uh okay so maybe we would have some value we give it a name and the inspector 
[57:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3429) so usually uh usually that's something readable uh that's not like um i don't know you usually want to make this very like user friendly and whatnot and this is the 
[57:19](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3439) internal variable name and we want this to be a float i want to set this to some value some default value right so now we have defined a single float property 
[57:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3450) so if we make materials we can then um we can then specify different values here for all of the different materials float4 for vertex position um yes usually it's float4 i actually don't 
[57:43](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3463) know if the fourth component is used for the vertex position there um i'm not entirely sure um there are lots of cases where you do use the fourth component though 
[57:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3474) but i don't think i don't think it's used here but but quite often when you're dealing with mesh data quite often everything you input is a 
[58:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3483) float4 regardless because that's sometimes the data you have from meshes are called vertex streams because usually or quite often you're 
[58:11](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3491) kind of using uv channels for stuff that's completely unrelated to uv mapping when it comes to like textures and whatnot 
[58:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3500) so so pretty much what it is it's just a bunch of data coming in from the shader and they're always defined in uh clusters of four so that's why it's a float four in 
[58:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3510) almost every case um so so if you're doing like a lots of like procedural generation and whatnot uh then quite often you just have float 
[58:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3518) force and then you write float far data into that uh but we're getting ahead of ourselves that's we're not there yet um okay i'm removing the texture stuff 
[58:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3527) because we're not gonna get into textures yet so we defined a property and then in order to use that property in our shader we also need a variable to go along with 
[58:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3535) it so i'm just going to do float value and then this is automatically going to get the the values from the properties in the shader right and yes autocomplete and syntax 
[59:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3546) highlighting for shaders is absolutely garbage um and it's only very recently that this is starting to get better which is why i recommend using writer 
[59:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3555) for this because writer does have good syntax highlighting and whatnot um yeah um okay so now we're going to the the mesh data structure so the mesh data you're getting here 
[59:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3567) are always per vertex as this is the per vertex mesh data so this is the vertex position if i can spell and in this case this is going to be the uv coordinates 
[59:42](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3582) uv coordinates are incredibly general uh you can use uv cornice for almost anything um it just so happens that quite often they're used for 
[59:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3591) mapping textures to objects um so so if you have a um let's see if you have a cube for instance uh and you open a uv editor uh let's see 
[01:00:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3607) if i can remember where to open it there we go uh you usually have some some 2d coordinate system where you are defining uh where 
[01:00:17](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3617) do we want to map a 2d texture onto this 3d object right which is kind of a complicated thing because you're you need to unfold this whole 
[01:00:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3628) thing you need to define where all these things should go usually you need to like pack them in ways that are like smart um it's a lot of work like just doing uv 
[01:00:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3637) mapping and like making that good um but yeah uh okay so so what is happening here we have float for vertex uh these are variable names so we can 
[01:00:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3648) name these whatever we want they could be just whatever um but the the colon here is is called a semantic and this is the thing that tells 
[01:00:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3658) us or tells the compiler that we want the position data to be passed into uh this field uh text card 0 refers to uv channel 0 which is usually the first one 
[01:01:11](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3671) and then you can you can continue doing this if you want to uh text card 1 would be the uv 1 instead of ub0 and so forth there's only a limited amount of things you can get out of this 
[01:01:24](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3684) quite often the things you're going to use is uv coordinates position always has to be there and then usually have normals here 
[01:01:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3696) um so if you go to um let's create a plane this one has a bunch of vertices um and 
[01:01:59](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3719) oh it's probably up here display polygons normals vertex neurons there we go um okay so if we take a vertex and move it away a little bit um you can 
[01:02:17](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3737) see these green lines right so this is the the normal direction of this surface um so if we change the uh the direction of this 
[01:02:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3747) you can see that the normals change along with them right so this is kind of the direction that the vertex is pointing which is usually used for shading and 
[01:02:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3756) whatnot to to make things look smooth or to make things not look smooth and so forth so you can see that if we make a little bump like this 
[01:02:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3765) you can see that the shading makes this this soft hump here because it's interpolating these normals across the faces but the normals themselves are defined 
[01:02:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3776) on a per vertex basis yeah so so when we when we refer to normal that is the normal direction of a vertex and there are all sorts of like other things you can get here 
[01:03:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3786) you can get um for instance you can get the vertex color which i believe is just a color i could be wrong i haven't used vertex colors for a long 
[01:03:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3795) time um and uh there's another one where you can get the tangent direction and tangents are crucially float fours and the four 
[01:03:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3806) uh the fourth component actually contains important information um so all of these are like useful whenever you're doing um whenever you need data from the mesh 
[01:03:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3815) right but if you just want to do a simple like apply texture to mesh then pretty much all you can do or all you need to do 
[01:03:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3824) is have your vertex position and the coordinates you want to apply the texture with right um but you don't need to use uv coordinates in order to use textures uv 
[01:03:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3835) corners is just one way of like getting a coordinate system for your textures right how do we know if we need to float two float three or four that depends on the 
[01:04:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3843) data um it kind of like the a normal direction is a three dimensional vector um so it's naturally a float three a tangent in unity specifically this 
[01:04:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3854) might be a more universal thing in unity the first three components is the direction of the tangent but the fourth component contains a sine information as in whether or not 
[01:04:24](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3864) it's flipped or whether or not your uvs are mirrored so it's just a kind of a hack where the w component just contains sign information the vertex color is always looked for if 
[01:04:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3875) you have colors anywhere float4 is always rgba um and yeah uh uv coordinates oh what's the difference between uv channels uh nothing uh the difference between uni 
[01:04:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3887) uv channels is what you define them to be right so a common thing uh that you do in games is that you might have uv zero might be for your diffuse 
[01:04:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3898) uh normal map textures so this might be the coordinates for your like all the texture that you apply to the surface uh uv one coordinates this might be the light map coordinates 
[01:05:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3909) so sometimes you have like different coordinates for for different types of textures and light maps is another one of those textures but quite often you want to have a different 
[01:05:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3918) layout for like color textures versus um like uh baked data like light maps uh for instance if you if you uv map something um like 
[01:05:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3930) sometimes you have a lot of overlapping uh like overlapping shells because you wanna use the same texture for the same place or for different places on the mesh but 
[01:05:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3938) if you want to encode light map data you can't have overlapping uvs right can meshes include multiple uv channels yes you can have many uv channels and if you want you can make them float 
[01:05:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3951) forward so if you're doing procedural generation you can just shove data in there so quite often the uv channels are just data and then how you use that data is 
[01:06:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3961) up to you but all it is is a float four associated with that vertex right so it's like having a uv map placement for each map you're using yeah you can use 
[01:06:11](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3971) it that way if you want right so that's the mesh data we haven't even gotten the vertex shader i feel like i'm doing this way too slowly okay v2f this is unity's default name for 
[01:06:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3982) the data that gets passed from the vertex shader to the fragment shader so the i usually like naming this something other than that uh so something like fragmentator input 
[01:06:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=3996) uh we could name it interpolators uh if we want that would be pretty accurate um let's go for interpolators okay fog 
[01:06:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4006) we're going to ignore fog um all right so this looks very similar but it's pretty different in terms of what this is going to be used for interpolators 
[01:06:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4016) is the way that we pass data from the vertex shader to the fragment shader is using this structure so everything we're going to pass to the 
[01:07:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4024) fragment shader from the vertex shader has to exist inside of the struct right because you can see the vertex shader returns interpolators um so in this case we're passing uv 
[01:07:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4036) coordinates uh and the position here again there are semantics here uh the semantic sv underscore position uh this is the clip space position of 
[01:07:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4046) this vertex or the clip space position it's a little weird to say for this vertex because the reasons i'm going to get into later um 
[01:07:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4056) but so so that's a clip space position of each vertex uh and then the uv channel this could be any data you want it to be in this case text card does actually 
[01:07:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4068) not refer to uv channels which is really confusing but in this case if you want to pass data you can just jam a bunch of text chords in here and 
[01:07:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4077) what you write to these channels is entirely up to you and they don't have to be uvs they could be absolutely anything as long as they are floats you know 
[01:08:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4085) whatever data type you have the maximum one is float4 for each interpolator all right so so it's important to note that the semantics here refer to specific uv 
[01:08:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4095) channels the semantics here is just a way to tell you that this is a different one it's kind of boilerplate i kind of wish you didn't have to define all of these 
[01:08:23](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4103) text chords because it feels unnecessary but anyway um for a very basic shader we might just pass a single like uv coordinates and then we might as well name this variable uv 
[01:08:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4112) right let's see why do we call these interpolators so let's say you have a mesh we're going to look at this side on right now right we have a vertex 
[01:08:43](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4123) and we have a triangle in this case it's just a line and we have some data in these things right um so that data could be a normal direction 
[01:08:53](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4133) right it could be the direction that this is facing um and the normal like i mentioned before 
[01:09:00](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4140) is part of the vertex there's no normal data here uh so the next vertex has a normal here next one has a normal here and the last one is a normal here 
[01:09:11](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4151) actually let's make this a little bit more clear okay so now we might get a normal like that um this one is going to be like the same 
[01:09:19](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4159) direction it's a little confusing but that's okay um okay so so now what's going to happen is that the vertex shader 
[01:09:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4168) again it's a for each loop over every vertex and then we pass data to the fragmentator where we're going to render for each pixel 
[01:09:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4177) and then you might ask yourself well the pixels are not just on the vertices you're going to have a pixel that's going to render in the middle of 
[01:09:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4186) this right it's going to be on like a triangle face somewhere um so then if we pass the normal to the fragment shader from the vertex shader the way that that data is going to look 
[01:09:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4198) in the fragmentator is that it's going to be interpolated as in it's going to be a blend between this normal and this normal so the interpolated data 
[01:10:08](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4208) in this case means that it's going to be the normal is going to like smoothly blend over to point more and more in this direction right and going this direction it's going to 
[01:10:17](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4217) start tilting down into pointing in this direction and this goes for any data so let's say you have vertex colors let's say you have the color red 
[01:10:25](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4225) there and then you have the color blue here so if you then get the vertex colors and you pass that to the fragment shader uh the color you're going to get at this 
[01:10:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4236) location is going to be a blend between these two because again it's interpolating or lerping if you want to use that between these two states uh so what you're going 
[01:10:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4244) to get is sort of um sort of a smooth blend like this right so then you're going to end up with sort of the halfway color of this 
[01:10:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4256) that's why they are called interpolators sometimes because any data that you set in the vertex shader that is going to be passed to the fragment shader 
[01:11:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4264) is going to be interpolated exactly in that way whatever data that might be right um so in the fragment shader you don't actually have access to 
[01:11:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4274) individual vertices or anything like that all you have is the interpolated data for any given fragment that you're rendering 
[01:11:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4282) and obviously there's going to be more it's not just a single pixel in the center there's going to be a lot of pixels all across and like for the for the 3d 
[01:11:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4290) analogy it would be exactly the same thing if you look at a triangle like this there you go uh and let's say we define vertex colors for this one too 
[01:11:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4300) so we have um we have red we have blue and we have green so now let's say we want to draw like we want to know what color this one is going to be so let's say we make 
[01:11:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4314) a shader that all the shader does is that it outputs the vertex color so let's say we have vertex colors in the mesh and in the fragment shader we just say 
[01:12:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4325) return vertex color and that vertex color was something we passed from the fragment shader the way that triangle is going to look is that it's going to blend these colors 
[01:12:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4335) together and it's going to look you know something something like this and this is the classic gl triangle if you have like that one friend that is riding their own game engine for some 
[01:12:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4347) reason they're going to be like oh look i made a triangle right and and the reason it's blending between these different colors is because you 
[01:12:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4355) supplied some color data in each of these corners of the triangle and the fragment shader blends that data um so that's the blending you're seeing in the center 
[01:12:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4365) if you want to get technical what this is called when you're blending between three different points like this it's called bary-centric interpolation 
[01:12:53](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4373) but it's basically just a lerp but for three points in like 2d space but you're not you don't have to do this yourself this is something that that it's going to do 
[01:13:02](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4382) on its own right so this happens whether you like it or not um it's going to interpolate all the data you have sometimes you don't want it to do that 
[01:13:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4390) um so so so yeah let's see there is a question um i feel like i missed a step where vertex data was passed into mesh data uh stuck thinking that opengl redefine a vertex 
[01:13:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4402) array object for the vertex data layout you don't pass vertex data into mesh data that happens automatically by unity so unity is passing all the data into the mesh data struct 
[01:13:33](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4413) uh so you don't need to deal with that um so so this is like autumn automatically filled out by unity okay so now we've just talked about like what interpolators are we haven't 
[01:13:43](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4423) actually looked at the vertex shader and here we got the actual vertex shader all right so so this is a function just like any other function um it has 
[01:13:52](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4432) some input parameters it has the the mesh data right um so the mesh data is coming in here so that's the structs so if we want to access the normals of 
[01:14:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4441) this mesh or the uv coordinates we can do that using the the v uh variable because that one is already populated with data um we're gonna ignore fog so i'm just 
[01:14:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4450) deleting everything fog related we're gonna ignore uh textures as well and the vertex shader all it returns is these interpolators right uh and interpolators 
[01:14:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4460) is like data you specify per vertex so what you specify in interpolators is uh what data do we want to interpolate across all of these across this whole surface right because 
[01:14:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4471) again all the data that each fragment shader has access to is the the interpolated version of this so when you're in the fragment shader the only color you have for this 
[01:14:43](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4483) fragment is going to be the color that you get here right the fragment has no idea what color this is what color this is and what color this is right 
[01:14:52](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4492) yeah so so so that's that's why you can sometimes call them interpolators because you get the interpolated value of whatever it is you define in the vertex shader okay 
[01:15:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4501) this is the vertex shader right now all we're doing is we get mesh data and then we set the um the vertex interpolator this is the specialized one 
[01:15:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4512) that always has the clip space position so unity has a built-in function called the unity object to clip position um if you want to get technical this is 
[01:15:23](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4523) multiplying by the mvp matrix which is the model view projection matrix but essentially what it does is that it converts 
[01:15:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4532) local space to its local space to clip space that's all it does uh and then it sends that to the interpolator called vertex right and usually o is used for the output if 
[01:15:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4546) you want like if you don't know why it's called o um right um so that's it that's all we're doing right now we can we can wait with uv coordinates 
[01:15:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4557) for now actually let's not do uv coordinates okay fixed for what is fixed for what is happening what is this um all right so you're 
[01:16:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4564) probably familiar with uh float4 uh in in unity c sharp this would be the same thing as vector four right and the same thing goes with like uh 
[01:16:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4574) float three float two and floats um but in shaders you have some extra data types that are lower precision than floating point precision uh so this is a 32-bit float but in 
[01:16:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4586) shaders you also have fixed and half so you can say uh let's just do flight um so float is a 32-bit float uh half is a 16-bit float 
[01:16:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4600) uh and then you have another one called fixed which is a little weird it's kind of like it's very legacy at this point and almost no platforms you're ever going to target 
[01:16:50](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4610) has the fixed precision uh but it's very very low precision uh i think it's around 12 or something weird like that i think it also depends on the platform so sometimes it's not just 12. 
[01:17:02](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4622) um anyway lower precision there we go and the fixed uh one is pretty much only useful within the like negative one to one range 
[01:17:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4633) outside of that you get so terrible precision that it's not going to be useful right half is pretty good for most things uh you very rarely need to use float 
[01:17:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4641) actually but half precision you can get away with a lot of things as long as you do them in the correct space uh float works well for anything in like 
[01:17:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4647) a world space and stuff like that about half is is usually the one you're going to use but when you're doing things in practice you can just use float everywhere 
[01:17:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4656) and some platforms don't even support half and fixed i think some like pc platforms never use half or fixed they always have everything in flips but if you're doing things on mobile 
[01:17:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4664) then half precision is going to be important and then there are some other variable names that might be useful um so again you can do this with vectors 
[01:17:52](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4672) too so while there's a float four there's also a half four there's also a fixed four so this would be the vector four version of that uh and they continue with this like 
[01:18:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4681) naming convention so if you wanna make a matrix uh then that's called float four by four um and again you can do half four by four for a 
[01:18:11](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4691) um half precision four by four matrix um and so forth yeah so this is how you do matrices where where this in in c sharp this the equivalent would be matrix four by four 
[01:18:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4701) right and you can do like three by three three by four matrices as well there are some data types bull data types uh kinda exist um but generally uh they're 
[01:18:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4712) equivalent to values of zero and one which is familiar to some of you because i'm sure some of you have used you know c or whatever where i think bullets is like equivalent to a zero and 
[01:18:41](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4721) one where you can just multiply by a bull so uh yeah so you could like multiply something by boolean value and that's going to compile and 
[01:18:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4728) false would be equivalent to a zero true is equivalent to a one you could have uh integer values as well but in many cases it's just going to be converted to a 
[01:18:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4737) floating point value anyway uh but usually you can have into values if you want to yeah but generally where you're going to you'll be using like 99 of the time it's 
[01:19:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4746) just floats everywhere because it's not going to matter for a very long time unless you'd like start optimizing things specifically 
[01:19:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4752) oh and then a fun thing is that this vector format kind of translates to everything else so you can use an into uh you can probably do a bool4 yeah it's shaders you can just add a 
[01:19:23](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4763) number for how many components you want in that thing um i think i actually never use these so i don't know if it's possible but i'm pretty sure it is 
[01:19:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4771) okay what's the value of doing lower precision does use less ram or is it faster it is generally faster and in some cases use less 
[01:19:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4778) memory as well depending on what you're doing so if you're doing things like gpu instancing then the number of bits that your properties can take or the number of 
[01:19:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4786) bits that they occupy um kind of determines how many instances you can have in a single rendering batch not to get into too much into instancing and what that is but 
[01:19:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4796) um but yeah generally on like lower end platforms you want to use lower precision stuff because the calculation runs faster you don't have to do a full 32-bit flip 
[01:20:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4804) and then uh now we're in the fragment shader we're going to delete fog and we're going to delete textures uh should you always use lower precision if you can 
[01:20:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4812) pretty much yeah uh that would be a good rule of thumb i would generally caution you to not care about it until you have to because you can run into some really 
[01:20:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4821) weird and hard to debug issues um when you're using like too low of a precision for something um so the way i approach it approach it is use 
[01:20:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4831) float everywhere until you have to optimize um or unless you like really really know what you're doing and you're not experimenting anymore 
[01:20:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4838) right cool so now we have our actual fragment shader um so the fragment shader has a semantic here uh this semantic is just telling us that 
[01:20:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4848) this fragment shader should output to the frame buffer uh in most cases um that should be the target of this fragment shader in some cases if you're doing deferred 
[01:20:59](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4859) rendering you can write to multiple targets but we're not doing that in this case it's just a single target so then we just use the semantic sv 
[01:21:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4867) underscore target again it's mostly boilerplate this is always there basically so now we have basically one of the most simple skeletons 
[01:21:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4876) of of a shader um you don't usually modify that much apart from adding code inside of the vertex shader and the fragment shader although sometimes the render pipeline 
[01:21:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4887) tags and the properties of course you need to modify okay so let's do the hello world of shaders let's output a 
[01:21:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4896) color um so let's do that well let's output a float four and let's give it give it a nice color give it a red there we go oh geez i don't want to autoform it 
[01:21:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4908) um all right so this is just a red color um and like i mentioned before in the math class we had a very good rule of thumb to remember is that 
[01:22:00](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4920) r g b a uh directly corresponds usually to stuff like you know x y z and w so these would be the components 
[01:22:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4934) of a vector right like the uh the x component and the y component z component and so forth um for colors this would be rgba right right 
[01:22:24](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4944) and of course you can also index them you can call this zero and this is one and this is two uh and this is three shaders make no distinction between colors 
[01:22:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4954) and vectors they're all the same all of them are float three or they're uh float four or float two or whatever um so so everything you do in shaders is pretty 
[01:22:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4964) much always structured this way so there's no color type in shaders and there's no vector type it's all the same right because they have exactly the same 
[01:22:53](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4973) structure you have a floating point or some other position value in up to four components oh what is a in rgba so a is usually called the alpha channel 
[01:23:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4984) alpha channel can be used for many different things uh but the most common use case for the alpha channel is used to represent transparency or coverage 
[01:23:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=4994) um so you can use it as a transparency thing or you can use it just to pass some other data along right the same way that sometimes with vectors 
[01:23:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5002) you also use a w component just to pass some data which is more common than having a four dimensional vectors all right so now we got the fragment 
[01:23:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5012) shader we're just returning a new float for uh that's just red all right so let's try this shader let's see if it works uh let's see output value vert not 
[01:23:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5024) completely initialized okay so this is it's complaining because i have not set the value of the uv interpolator so i'm just going to comment that out 
[01:23:53](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5033) um there we go all right so we got our first shader but we need a material we can't apply a shader to an object so even though we might have an 
[01:24:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5043) object um we can't just drag and drop the shader onto that object we need to have a material to define what are the properties going to be for 
[01:24:11](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5051) this object so i'm just going to create a material there we go and this is now using our shader and then we can apply that to our object 
[01:24:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5060) um yeah and there you go this is our shader uh we made a shader it does indeed output red something i love about shaders is that 
[01:24:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5070) we can do oh swizzling yeah so swizzling is a funny name for a pretty basic uh but very useful thing of like if you have a float fart 
[01:24:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5080) uh my value um then you can access these components or cast them to a vector two by doing my value dot x y uh and then that would be a float two um 
[01:24:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5096) like this um which is pretty useful uh so this is like a you can just cast it to a vector two and you can replace x and y with r and g for red and green um so you can use 
[01:25:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5106) whatever like uh whatever components you want to use from this set right or not the numbers so so these letters 
[01:25:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5113) um and you can even flip them so you can do my value dot gr and it's going to flip the um it's going to assign the green channel to the red channel 
[01:25:25](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5125) and the red channel to the green channel so this is called swizzling and it's incredibly useful um and sometimes if you just want like want to output a grayscale of some color 
[01:25:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5135) you can do dot xxx um and now this is going to just take the first component and then splattered out on all the four uh components of something 
[01:25:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5144) um super useful to to have and yes it is frustrating to not have that with unity's vector type um so we we made a color right we output a red color uh so so 
[01:25:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5156) what can we do with this well we can we can make it output green if we want right um so we recompile now it's green uh can you do rrr1 to automatically put one in 
[01:26:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5167) the alpha channel no but this is something that i am pushing hard for i really really want this to happen um and 
[01:26:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5176) my my girlfriend ashley is working on she's working on rust gpu which is basically like a way to write shader code in rust uh and i'm trying to get her to 
[01:26:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5187) push for that change there's some discussion about this on the internet as well but it gets complicated because if you want the first component to be zero then that gets complicated to compile 
[01:26:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5197) because doing dot 0 is not a valid variable name or a field name right um but yeah anyway uh all right so now we have a way of outputting 
[01:26:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5207) a color to the screen and we can move this around and it's following the you know the transform of this object which um 
[01:26:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5217) which is like seems like it's a very basic thing but the reason this happens is because we told it to convert local space to clip 
[01:27:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5226) space here so this is not always the case uh so so the default space is the clip space right so if we just set this to v.vertex 
[01:27:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5236) it's going to be like stuck to the camera it might not even render no wait okay we got it so so now we just took this mesh but we're rendering it directly in clip space 
[01:27:25](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5245) um so now the position of this object doesn't matter whatsoever um because we're not using that matrix right now it's just like slapped onto the screen 
[01:27:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5254) so this can be useful if we're doing stuff like post-processing shaders because for post-processing shaders you usually want to have something that covers the entire screen 
[01:27:43](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5263) right it doesn't it doesn't have a position it's just a global thing for the frame right okay oh the difference between like normalized device coordinates and clip 
[01:27:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5274) space it's yeah it seems really messy and it's really hard to find good information on that it just seems like it's mostly a difference in like axis 
[01:28:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5283) orientation and uh whether or not depth should go from zero to one or negative one to one um whereas in clip space i feel like depth goes further 
[01:28:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5292) but in normalized device coordinates is squished into either zero to one or negative one to one right you don't you don't have to know that in order to write shaders though which is 
[01:28:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5300) kind of nice at least you're riding your own engine but that's not why we're here how compatible are the shaders you write in shader lab opengl vulcan directx um 
[01:28:29](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5309) unity cross ports too all sorts of rendered i don't even know what to call them render apis um so like if you compile something for ios 
[01:28:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5318) it's going to compile to ios metal right um so like the the actual back end is you don't have to care about that you only write stuff in hlsl and then 
[01:28:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5328) unity is going to handle all the like translation to all the different apis is it all compiled to spear v nowadays i don't know i would guess not but maybe 
[01:28:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5338) you can probably look it up i don't really know how the internals work there like i quite often mention i pretty much only learn the things i have to learn so if there's information that's mostly 
[01:29:08](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5348) useless to me i tend to not pick it up so for me to make things look pretty in a game and to code the shaders that i want i don't need to know that 
[01:29:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5358) i just need to know that it compiles for the target platform can you have multiple shaders on one object for different purposes um say i want to outline shader when i 
[01:29:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5366) hover over the objects but i also want to have another shader on them at the same time um usually you can like do stuff like you render the mesh twice with different 
[01:29:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5375) shaders yes you can do that um outlines in particular are like notoriously complicated so sometimes outlines are even done as a post-process effect rather than 
[01:29:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5386) you know something that's in the shader of the surface itself so it kind of depends on what you're doing rust gpu looks like it uses spear v 
[01:29:53](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5393) uh i'm pretty sure yes actually rust gpu uses spear v right thumbs up yes is it possible to replace vfx with shaders for non-art background so you can't like well it depends on 
[01:30:08](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5408) what you mean by the effects and what you mean by shaders because every all the vfx that you use and draw do use shaders um shaders are kind of 
[01:30:17](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5417) inevitable everything that you can see in a game it's pretty much always rendered with shaders um but if you're asking like can i 
[01:30:25](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5425) replace like artist authored texture data with shaders sometimes but sometimes it's also like pretty like computationally 
[01:30:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5435) expensive to do that in real time when you can just use the texture um that someone is like authored and usually it's like it's also a different style 
[01:30:43](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5443) and it really depends on what you're trying to like artistically achieve and what your capabilities as a team are so let's continue so we made a very simple shader uh 
[01:30:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5454) with a hard coated color all we do here is we have a fragment shader that is positioning the vertices at some position in the world 
[01:31:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5465) right in this case it corresponds to the transform of this object um and the fragment shader the only thing it does is it returns a green color 
[01:31:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5475) that's it um so let's do something that's a little bit more useful and interesting um so first off let's um let's make a property because maybe we want separate materials for this 
[01:31:29](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5489) maybe we want one that's green and another one that is a red let's say that we want to have a green one and a red one and we want to be able to configure this 
[01:31:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5500) um so okay uh we want to have a property for the color of this so this is a float property but in our case we want a color right uh so let's call it a color 
[01:31:52](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5512) and give it a name and color uh and we just call it a color color color color um and a color has four components so we can default it to some value let's 
[01:32:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5523) default to um actually we can probably just do do one there we go one across the board white color and then we want to be able to access 
[01:32:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5535) this property somewhere right uh the properties that you define here usually you need to define a variable for that too or a field for that 
[01:32:25](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5545) and again colors are uh have four components so you can either do float four fixed for half four but we're just going to do floats and so so now we have the color 
[01:32:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5555) property and we can set this color property in the different materials that we have so then we can access this both in the vertex shader and the fragment shader we 
[01:32:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5565) can access the properties from anywhere which is really really useful so in this case instead of outputting a hard coded color value we're just going to output underscore 
[01:32:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5574) color save that go back to unity and so now if we select the let's see this is the supposedly red one let's 
[01:33:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5583) copy that and assign the green one so if you now look at the material of this we now have a color property um on this material uh so we can then modify this color 
[01:33:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5595) uh so this was the green one so let's set it to green color and then we have the red one so let's set that to a red color there we go so now we have a 
[01:33:25](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5605) green one and a red one um and we cannot configure this per material because we have this property up here right 
[01:33:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5614) uh so this property has a field called color and we can then access that field in the fragment shader which again the fragment shader all it does is return a color for the current fragment 
[01:33:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5625) or sometimes pixel that we want to render but so far we haven't actually passed any data from the vertex shader to the fragmentator all we're doing 
[01:33:53](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5633) is just like [¬†__¬†] out a color right um or i guess that's all you always do in a fragmentator but in this case we want to get a little fancier so what if we want to pass something 
[01:34:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5643) from the vertex shader to the fragment shader okay so let's talk about the concept of uv coordinates so now we're going to get into what uvs 
[01:34:17](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5657) are oh actually we're not going to do uvs uh we're going to do normals we're going to skip uis all right so in order to pass something 
[01:34:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5668) from the vertex shader to the fragment shader we need to pass that in the interpolator structure right and we need to have a float3 value 
[01:34:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5677) because normals are it's a three-dimensional vector that's a direction uh so let's call that normal and then the semantic we use for that uh which is called the text chord zero it 
[01:34:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5687) doesn't matter this does not correspond to uv coordinates in the interpolator structure uh this corresponds to just one of the data streams that we have coming from 
[01:34:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5697) the vertex shader to the fragment shader and all right so now we've got the normal in the interpolators and we can access that because we have 
[01:35:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5710) the interpolator's input in the fragment shader uh so we could do i dot normal and now we're going to access whatever we set the interpolator to here 
[01:35:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5720) right uh now i dot normal is a float 3 but the fragment shader is going to return a float four so we need to like specify what's gonna what's the fourth component going to be 
[01:35:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5731) well we can do float four and then we pass i dot normal in and that's automatically gonna populate the xyz components and then we're just gonna set the w 
[01:35:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5740) components to one because usually in this case that's usually alpha if you're using alpha blending or like transparency but in this case i 
[01:35:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5748) guess it doesn't matter we could just make this a float three but whatever um yeah so in this case it's just making a float for out of a normal direction which is three 
[01:35:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5758) components and we're adding another component to that okay um so now we are outputting the value that we have in the interpolators but we haven't set that value yet the vertex shader needs 
[01:36:11](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5771) to assign something to the interpolator called normal right um so in this case we would do o dot normal equals and then we give 
[01:36:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5782) this some value and again like i mentioned before this can be anything it doesn't have to be normal we can even pass the color in here 
[01:36:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5790) let's say we pass the color.rgb into odopnormal then if we go back to unity we're still just looking at the color now but instead of directly outputting color 
[01:36:42](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5802) here we're passing it through an interpolator um so so all we're doing here is just piping data to the fragment shader but we don't want the color we want to 
[01:36:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5811) show the normals of this object just visualize the normal directions right the way we can do that is that we need to access the mesh data right because the mesh data contains the 
[01:37:00](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5820) normals because again mesh data has the normal here and we use a normal semantic to make sure that it populates the normals variable with the normals of the mesh 
[01:37:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5829) um so if we now go back here we can do uh o.normal equals v dot normal and this is very common you will very often just pass data just pass data through the vertex shader 
[01:37:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5842) immediately to the fragment shader so this one is not actually doing any transformation and whatnot but we should and we're going to get to that later um 
[01:37:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5851) all right so we're passing the normals from the mesh data to the interpolator that we're going to have across all the triangles that's going to get 
[01:37:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5860) passed to the fragment shader so now we can access the normal so now if we go back to unity we have these very colorful mango spheres um 
[01:37:52](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5872) so so now what this one is showing is that it's displaying the direction of the normal for every given pixel that we are rendering and a way to sort of visualize this is 
[01:38:02](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5882) that if you consider what normals are it's the direction out from the surface right and again like i mentioned before shaders make no distinction between 
[01:38:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5892) vectors and colors so what we're doing now is we're basically outputting the vectors as a color so on top of this mesh it's green right 
[01:38:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5901) and what that means in a vector is that we have the values 0 1 0 because in the center component where the y component and that one is one which means it's 
[01:38:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5912) pointing directly upwards right so that's why the green on the top on the x-axis the normal is pointing directly along x and that's why it's red on the z-axis 
[01:38:41](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5921) it's pointing along z and that's why it's blue um so what this is doing is that it's it's basically just showing the direction of the normal why is normal 
[01:38:49](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5929) semantic in interpolators text card weight s um it's text card zero in this case so text cord this is kind of just a name to specify a slot 
[01:39:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5944) of where you want where you want to pass data through so like i mentioned in mesh data tax code specifically refers to uv coordinates but in the 
[01:39:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5954) interpolators text cord is just an index you don't really need to think of it as anything related to anything when it comes to mesh data so in this case tax code is something 
[01:39:24](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5964) completely different it's just the semantic you use in order to separate all the different values you have so if you want to add something more you name the next one 
[01:39:33](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5973) text card one name the next one text core two and so forth and this could be anything this could be the tangent this could be as just some values it 
[01:39:42](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5982) could be whatever you want right so this is just a way of saying that you want to have some channel where you pass some data into it right i'm seeing the black side render 
[01:39:53](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=5993) correctly does that mean you can have negative color values output by the fragment shader and nothing will break yes uh shaders are like inside of the vertex shader and the 
[01:40:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6001) fragment shader they're kind of designed to never crash uh so if it compiles it will output something the downside of this is that you can 
[01:40:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6009) like you can literally divide by zero um and you can get nan propagation throughout your rendering pipeline um unless you're careful uh because shaders will not 
[01:40:19](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6019) like crash for that reason um but it kind of depends on what you're rendering to but yes you can render you can have negative negative color outputs 
[01:40:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6027) you can have values above one it's not restricted to zero to one and depending on where you're outputting it to it has different effects um it is possible to render to a texture 
[01:40:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6038) um and it's also possible to render to the frame buffer in this case we'll render it to the frame buffer but you can render to like a floating point texture if you want to 
[01:40:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6048) in which case values below zero are going to stay values below zero what does nad display as uh i don't remember um i don't quite often run into that and 
[01:40:59](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6059) there are like some k like sometimes there are protections against that to prevent non propagations as well i think the newer render pipelines in unity has protection for that 
[01:41:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6067) okay cool so we're just passing the normals through uh all right so so now we're basically showing the normals of this object in color and this applies to any 
[01:41:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6080) object so we can replace this mesh it doesn't matter what mesh we're using right so we can just use a capsule or a cylinder 
[01:41:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6090) and everything behaves as we would expect it to right so that is the normals all right let's look at something else um 
[01:41:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6098) oh actually one more thing um so if we rotate these you can see that the the normal that we're outputting is not in world space right um because you can see that this 
[01:41:49](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6109) corresponds to the local space axes or in this case it's sometimes called uh model space or mesh space so so these normals are are not converted to world space and we might 
[01:42:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6121) want to do that so so this is where we can start figuring out you know where do we want to do this math because technically 
[01:42:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6130) we could do that either in the vertex shader or in the fragment shader so if you want to do that we would do a unity uh is it model or local probably local 
[01:42:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6147) objects to world normal there we go object space is what unity calls it uh so this is a unity macro that basically just converts this from object space to world space right 
[01:42:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6157) uh it's called normal because this macro does some extra stuff depending on how you configure unity so there is like there are lots of shenanigans that happen 
[01:42:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6167) if you like scale your object with non-uniform scaling uh because then you want to be you want to make sure that the normal is normalized 
[01:42:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6174) um so so there are all sorts of like things you might be careful with depending on how your object is set up uh but if you don't have any scaling then it's pretty much just a matrix 
[01:43:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6183) multiplication right uh as you can see here it's a mole which is multiply with matrices so it multiplies a normal vector with a three by three matrix of world to object 
[01:43:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6194) right and yes this is from unity's include file and you can do this manually if you want to so if you want to do this manually you 
[01:43:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6202) would do mole um and then v dot normals uh another matrix here which one do they use uh this one 
[01:43:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6214) there we go so so unity world to object is a four by four matrix but if you're doing matrix multiplication of a direction you can just discard 
[01:43:42](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6222) um the fourth column in a row right um yeah all right and this is a little confusing because it says world to object but what we're actually doing is object to world but the reason 
[01:43:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6235) for this is that the uh the parameter order of the multiply operation changes the matrix the matrix will either be 
[01:44:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6245) transposed or not um so if you want to make this a little bit more readable which i would do i would never structure it that way um i would instead 
[01:44:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6253) use unity object to world and then flip the arguments so now it's a straightforward multiplication of a three by three 
[01:44:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6261) matrix uh with the uh object space normal and then we transform it to world space right yeah and we don't use any scaling so we don't need to normalize this 
[01:44:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6271) uh so we can just leave it as this oh you could also use the unity matrix m this is the model matrix um so if you've heard about the mvp matrix the model view projection matrix 
[01:44:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6284) this would be equivalent to the unity objective world uh unity themselves recommend using their names because they usually define like those names to work in different 
[01:44:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6294) ways depending on like platforms it gets really complicated once you get into vr and stuff like that so i usually it's best to use unity's built-in stuff for this 
[01:45:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6303) uh but i just wanted to show you how you could do space transformation manually so now this is no longer in local space so if we rotate this and then recompile the 
[01:45:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6313) green is gonna change direction right so now no matter how we rotate this the um it's always going to correspond to world space normals right because we 
[01:45:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6322) transformed those uh vectors um the same thing goes for this one you can see that the this one is going to change to green we 
[01:45:33](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6333) can change it to red and we can change it to blue all right um so we could if we want to we could do this in the fragment shader 
[01:45:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6344) we could pass the local space normals here and then we do this operation in here right so if we recompile nothing changes it works exactly the same weight as 
[01:45:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6355) before but this is where a one of the most common ways to optimize shaders comes in so if you want to think about how you can make a shader faster 
[01:46:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6367) try to think about how many vertices do you have versus how many pixels or fragments do you have and in most cases not all but in most 
[01:46:17](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6377) cases you have more pixels than you have vertices um so you usually want to do as much as possible 
[01:46:24](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6384) in the vertex shader and do as little as possible in the fragment shader um it could be the case that you have some really like high vertex count on something that is 
[01:46:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6394) very far away in which case it might not have like maybe it's only rendering to like 32 pixels but it has like 16 000 vertices in that case 
[01:46:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6404) it's going to be more expensive in the vertical shader right but in most cases you're going to be running more pixels than vertices in a mesh um so usually something like this if you 
[01:46:53](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6413) can put it in the vertex shader then you should put it in the vertex shader um presuming you didn't need access to the like local space normals in the fragment 
[01:47:02](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6422) shader all right so normals is just one type of data that we have in our mesh um so let's move on to uv coordinates so we have the uv 0 uv channel 0 as 
[01:47:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6433) our mesh data input and then in the interpolators we want to send the interpolated uv values to the fragment shader so we need we 
[01:47:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6442) need a channel to do that on uh so we're just going to call this uv so now we have uv and then in the vertex shader we do o dot uv 
[01:47:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6452) equals v dot uv zero all right so this is again just a simple pass-through we're not modifying this uh at all here okay so what do the uv channels look like let's let's just 
[01:47:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6465) output the uv channels so i dot uv zero one because uv channels are or uv uh coordinates if you're using the traditional uv coordinates that you have 
[01:47:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6474) like in your mesh editing programs usually uh uv coordinates are 2d coordinates right um so in this case it's a 2d um vector that we pass into the float 
[01:48:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6486) for so then it combines it into a full float four where z is zero and w is one uh so what does this look like 
[01:48:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6494) well uh we get even more mango shapes so the uv coordinates depends on how the object was uv mapped when the artist authored this object right 
[01:48:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6506) and it's probably most helpful to look at the way that it looks on a single quad um so here we have a single quad um so what uvs are if you think about the 
[01:48:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6520) colors that we're seeing here they directly correspond to two dimensional coordinates right because colors are vectors and vectors are colors and shaders 
[01:48:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6528) this is a very useful way to debug this um so the vector or the uv coordinates or the color is zero in the bottom left corner 
[01:48:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6537) because it's fully black and along the bottom side you can see that it's increasing in red and red is the same thing as the x component so the x coordinate is 
[01:49:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6547) increasing along here but on the other axis it's increasing along green which is the y coordinate and then diagonally it's increasing across both which would make 
[01:49:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6556) for a yellow color so what we're visualizing is 2d coordinates on this mesh and if you want to visualize using one of the components we can do i dot uv.xx 
[01:49:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6567) for instance so now we take the x component and splat it out across rgb um and now we just see the x component of the uv coordinates which just makes 
[01:49:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6577) for horizontal gradient right and we can do the same thing for the y coordinates and now we'll get the the y coordinate there uh it's just that when we visualize both 
[01:49:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6587) at the same time we tend to get this uh manga vibe going um because it's just red and green being added together in a single color so so this is the coordinates that you get in 
[01:49:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6598) a 3d application when you are modeling something so if you have a cube like this then depending on what face it is the colors would be different 
[01:50:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6607) depending on where it is right because that's literally what the uv coordinates are they specify a 2d coordinate on your mesh 
[01:50:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6615) yeah not always but usually here's here's a good thing to talk about so let's say let's say we want to modify this with a property let's say we want to scale 
[01:50:24](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6624) these let's say we call it uv scale and that's going to be a single float value and it's going to start with 1. that's a good default for a scale and then we need a variable for that so 
[01:50:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6636) we're just going to call it scale and now we want to scale these uvs based on this parameter right so if we then want to scale this then we can kind of consider like what 
[01:50:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6648) does scaling mean what we kind of want to do is that we want to multiply these vectors so that they get either longer or shorter right um and you you 
[01:50:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6658) know vector math at this point so if you multiply by scale the coordinates themselves will change depending on what this value is 
[01:51:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6667) and again we can do this in the fragment shader as well but since it's faster to do it in the vertex shader we're just going to do that in the vertex shader 
[01:51:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6675) um so now we scale these uvs with some value so if i go back to unity what happens if we tweak this value now is that you can see that the coordinates 
[01:51:25](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6685) themselves change um if we put the scale to 2 for instance you can see that it's maxed out at yellow here and then this quadrant is just 
[01:51:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6697) completely yellow because all of those values have gone above one right uh so the color is clamped but the underlying data is not uh you still have 
[01:51:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6706) values outside of zero to one but visually you can your monitor can't show negative colors and your monitor can show colors above one uh so that's kind of the range that 
[01:51:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6716) we can see stuff in um but you can still use those values in the shader itself right so so this is how you can very easily modify data like this 
[01:52:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6725) and the part that i really love about working with shaders is that it's kind of fascinating how closely you can visualize math and like 
[01:52:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6736) things you would do in math so so in this case we multiplied by scale so what if we do some other stuff let's say we have 
[01:52:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6746) something called an offset let's call that offset uh default is zero the additive identity there we go all right so if we have a scale and an offset 
[01:52:42](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6762) then usually offsetting offsetting would be that you add instead of multiply um whether or not you want to offset before or after scaling i guess depends on your use case 
[01:52:52](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6772) um but in this case um we're going to do it before actually you do want to do it after i don't know things always feel a little reversed 
[01:53:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6783) all right so now we have an offset parameter so let's set the scales at 1. so now we can offset these uvs diagonally right we can put a negative value there 
[01:53:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6793) and we start moving the coordinates to be negative um or positive values and they're all like positive right and this is where things start becoming 
[01:53:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6801) really really powerful because if you start thinking about how maybe we want to you know fade something from one color to another over some specific range 
[01:53:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6810) this is where we can start doing stuff like that so let's say for instance that we want to make a gradient from one color to another over the uv coordinates let's say that 
[01:53:41](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6821) that's our goal uh all right so what are we going to need um we're going to we can start out by having the two colors right red color a 
[01:53:50](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6830) and color b so it's going to be our start and end colors um and let's say that we just want to do this across the x-axis 
[01:54:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6841) uh so let's ignore scale and offset for now just pass the uv coordinates through and now we want to blend between two colors oh we also need the the properties here 
[01:54:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6852) color a color b don't use these anymore all right so you probably remember that we talked a lot about the function called lerp 
[01:54:23](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6863) right and lerp is basically a way to blend between two values based on a third value usually between zero to one right and if 
[01:54:33](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6873) we think about the uv x-coordinate then this is a value from zero to one right zero on the left side it's one on the 
[01:54:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6884) right side so we can use this as the t parameter of a lerp function between two colors um so let's say we want to make a variable let's call that our 
[01:54:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6894) um output color and we're gonna learn and in shader code you just type lerp the from value is going to be color a the two value is going to be color b 
[01:55:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6906) and the inter interpolator is going to be the x coordinate of the uvs right and then we can output that color 
[01:55:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6916) and okay so this is basically blend between two colors based on the uh x ue coordinate all right and we're back in unity and now we can set this to some color 
[01:55:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6936) and we can set this to some other color right so now we've done a very very simple blend between two colors and we constructed a gradient uh 
[01:55:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6946) with very like few instructions right it's a simple lerp between two colors and all it's based on is the uv coordinates of of this object um and then we can like 
[01:55:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6957) then we can start modifying this however we want uh let's say you want to be able to change where where the where the gradient starts and ends maybe 
[01:56:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6966) that could be a useful parameter to tweak um well in that case um it might be useful to have two ranges for instance so let's call it color start 
[01:56:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6980) color end um there we go uh and in this case let's use a range instead so range is just a quick way 
[01:56:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=6995) to tell unity that we want the inspector to have a slider between these two values in this case it's just gonna be zero to one all right so we have color start color 
[01:56:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7004) end uh we wanna start at zero and end at one by default and then we wanna add these as properties um so as with the other ones uh it's just 
[01:56:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7015) going to be it's just going to be float4 for all of these things right uh so it's float four or no actually these are not flute first sorry uh since these are just a single value 
[01:57:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7025) uh we just have color start and color and um as single values all right um cool so what we then want to do is that uh we want to change 
[01:57:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7036) or we want to remap the x coordinate of the uvs to some other range right so so for now let's let's stop looking at colors and let's go back to looking at 
[01:57:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7047) uh the uh the actual values we want to use as a t parameter uh and this is really really really useful because in shaders you can't really log things so shaders 
[01:57:39](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7059) you usually want to just you usually just want to output some color and that is the way that you can see what is happening in your shader um so 
[01:57:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7067) you if you're writing shaders you're going to have a lot of commented outlines that just say return some stuff because it's really useful to debug stuff that way so in this case we 
[01:57:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7075) want to see i.uv.x so this this is the x coordinate that we're dealing with so now we want to make these two sliders uh change where this gradient 
[01:58:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7084) starts and where this gradient ends right okay so we've talked about this during the math class um and the a very very useful function that you can use to do this is called 
[01:58:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7095) inverse lerp surprisingly and oddly enough inverse larp is generally not built into shader languages 
[01:58:23](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7103) there is almost an inverse lerp called smooth step but that one also has smoothing and it's kind of i don't know it's different right 
[01:58:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7111) so sometimes you have to define your own functions so let's just define our own function so let's call this inverse lerp we have a start value we have a an n 
[01:58:42](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7122) value and we have the input value right so we got inverse lerp and the inverse verb function is really really 
[01:58:50](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7130) straightforward uh in case you don't care about divisions by zera in which case uh you just do uh return um 
[01:58:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7138) let's see it's uh v minus a divided by b minus a i'm pretty sure that's the one um so now we have an inverse larp function 
[01:59:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7149) and now we can use this to change where this gradient starts and ends right so all right let's call this value the t values that's usually what it's called 
[01:59:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7160) in the the third parameter of the lerp function uh so we're going to do inverse lurk color start and color end and then we're going to have the 
[01:59:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7172) actual uv coordinates that's a gradient input so then we get the t value and let's just return that t value for now all right let's see if 
[01:59:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7180) this works so if we pull the start position it seems to actually change the start and if you pull the end of the gradient that also changes the 
[01:59:50](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7190) end point you can also reverse this um the inverse layer doesn't really care what order this goes in but yeah so so this is now a very simple 
[02:00:00](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7200) thing where you can just change where this gradient goes right all right and then we want to uh then we want to make this uh be between two colors and not just black 
[02:00:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7209) and white but all the data is pretty much there right uh so um you might think that all you need to do is just bring this back and change 
[02:00:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7218) this to t there's one more thing we need to do um oh sorry um i still need to return it great so so now we're using the t value that we we're just looking at 
[02:00:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7232) this value from zero to one um and we're using that and as the t parameter of the lerp between color a and color b so now if we go back to unity recompile 
[02:00:43](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7243) we now have a blend between two colors kinda we it looks like we have more than just two colors here right and if you can guess why that is well 
[02:00:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7254) how how could this happen why is there yellow does anyone have any idea and then i'm like an awkwardly sit and hell yeah you got it 
[02:01:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7263) so basically the the problem is that because shaders don't natively clamp everything between 0 and 1 you need to make sure that you do that 
[02:01:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7272) wherever you want to keep things within that range so what's actually happening is that the t value here of the inverse lerp actually has values 
[02:01:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7282) outside of zero to one so even though we might return t then we can't tell if these values are above or if they are above one or if these are 
[02:01:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7294) below zero um there are ways of like there are ways of checking this um so one way that i like to use um for checking like whether or not 
[02:01:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7305) something is overshooting uh is that i usually like using a function called frac so frac is a very simple function that basically frac is the same thing as 
[02:02:00](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7320) doing some value and then subtract floor of that value and in in the human language what that means is that values are going 
[02:02:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7330) to repeat within the 0 to 1 interval so what would happen is that if we have values that go above one here we would see this gradient repeat multiple times 
[02:02:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7341) in both directions right but if this is clamped then we wouldn't see a repeating pattern because then all of these are the same values all right so let's uh let's use 
[02:02:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7352) frac in this case let's do t equals um t equals uh frac of t and then let's go back to unity and we can see that they do indeed repeat right so yeah and we don't 
[02:02:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7365) want that we want to want to clamp this between um between zero to one and not repeat the pattern uh you could if you want to but that's 
[02:02:53](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7373) not what we're going for now so we're not confirmed that this one is not clamped um but let's clamp this and see what happens so we have a frac 
[02:03:02](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7382) and then the way that you clamp things uh in shaders is quite possibly the worst name of a function ever to exist in the universe 
[02:03:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7394) the way that you clamp is that you use saturate which is a [¬†__¬†] name for what this is doing so saturate basically means if it's less 
[02:03:25](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7405) than one make it zero or if it's less than zero make it zero if it's greater than one make it one it's the same as the clamp 01 function 
[02:03:33](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7413) in unity um in the unity c sharp um but yeah so that's what saturate is doing um it just clamps it between that range so if we go back to unity now 
[02:03:42](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7422) we can now see that it has clamped this pattern is not repeating below or above it right um because we clamp it and then we do 
[02:03:50](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7430) uh the frac operator which would show us repeating gradients in case it was still increasing here or if it was still decreasing here so it's a good that means that we have now 
[02:04:00](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7440) successfully clamped this and now we know that these values are stuck at one these values are stuck at zero so now if we go back to the gradient 
[02:04:08](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7448) we now have a single gradient here and it doesn't overshoot into other colors this might be a topic for later in which case don't answer oh i don't know i haven't read it yet 
[02:04:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7458) what's the difference between what we're doing now plus a clamp and smooth step so smooth step is a little different because smooth step is an inverse larp it's a clamp and 
[02:04:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7468) a cubic function so smooth step has like three different things that have a bunch of operators that you might not always want to use 
[02:04:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7477) so smooth step is yeah it's a combination of those three three things yes it's not a lerp it's a cubic smooth which in and of itself can be useful um 
[02:04:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7487) but yeah oh for context the reason i think saturate is one of the shittiest names for a function is because like you're literally dealing with colors 
[02:04:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7496) in shaders and saturate means something completely different in the context of art and colors which is really frustrating to me does that make sense any questions so 
[02:05:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7507) far is saturate also part of unity's include nope saturate is a built-in function in the language itself usually the page i go to is the cg 
[02:05:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7516) deprecated documentation here you go the the standard library uh in cg lists a bunch of functions uh so if we go here and we search for frac 
[02:05:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7527) you can see that we have frac and you got all the different overloads for all the different positions and the input values and whatnot oh oh it's also really useful uh it does 
[02:05:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7537) also show you if you were to implement it manually this is how you would do it um so which is yeah that's the thing i was just mentioning which is 
[02:05:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7545) funny because then we can look at smooth step and you can see that smooth step is doing a hell of a lot more than just an inverse lerp right and so if we look at smooth step this is 
[02:05:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7557) a linear inverse lerp and then it's clamping it between zero to one so so this is the part that we were doing manually and then it's doing a cubic smoothing of 
[02:06:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7566) that function um so so it has like a lot of extra math that you don't always want uh whenever you're doing this so just show you what that looks like 
[02:06:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7581) there you go so this is the cubic smoothing function uh whereas a the one we were doing is the green line here where it's just going to uh it's just a linear blend where a smooth 
[02:06:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7591) step is doing a the smoothing curve on top of that i guess this should just be between 0 and 1. um yeah so that's what smooth step is doing 
[02:06:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7600) this in saturation basically rgb times x it's not rgb times x like if you do that you multiply it by a value and that would still make it shoot beyond zero to one 
[02:06:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7611) right if you're talking about the like the artistic saturation just multiplying is not going to change the saturation of it it's going to change the 
[02:06:59](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7619) overall brightness but it's not going to change the saturation which is sort of a separate thing if you want to like increase the saturation of something 
[02:07:08](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7628) you first need to figure out what is the grayscale value of this and then do the opposite of that so so usually something you can do is you can 
[02:07:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7636) you can interpolate away from the grayscale version of that color which is like a sort of separate operation from from the the thing that shaders call 
[02:07:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7646) saturate which is just a clamp between zero and one which again it sucks that it's called saturate it should just be called clamp 01 or whatever 
[02:07:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7654) in that case the shader saturation makes no goddamn sense no that's why i hate the name of it it should be called clamp 01 but that's why it's called clampo1 and 
[02:07:42](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7662) shaderforge literally yes that is why it's called that let's see uh we don't have that much time left so i can just like juggle a few math things to show you 
[02:07:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7671) like what you can do with this type of stuff let's give it some more pleasing colors i didn't like these colors this is better i like this better okay so so one thing that is that is really 
[02:08:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7681) neat is that um so so let's say you have your [Music] actually let's let's keep this for later oh that's kind of necessary oh by the 
[02:08:17](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7697) way um things in shaders automatically cast from a single float to a float four so we're returning just a single float 
[02:08:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7707) but this is basically going to take the x component and swizzle it out to all four channels of the the float4 or the four components um so in this case there's an implicit cast 
[02:08:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7717) and so right now we're just showing the uh the basic uv coordinates that we looked at before just zero to one from left to right um and one thing that's really nice once 
[02:08:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7726) you get into making shaders uh this way and once you can like harness the way that the math functions work is that you can get a lot of effects out of it 
[02:08:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7735) that might otherwise be really hard um especially when you get into like animating animating things and like trying to do procedural stuff so let's say for 
[02:09:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7743) instance i want to make a triangle wave out of this um then there are like you can sort of deploy a bunch of math here and then just sort of make it work um so say we want 
[02:09:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7754) to make a triangle wave how can we go about that well we can sort of look at decimals for range values so now we have a simple curve from 0 to 1 
[02:09:25](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7765) right and let's say we want to make a triangle wave out of this well we do have the the function abs right which we talked about in the math class which basically means 
[02:09:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7776) if it's negative make it positive um so it's the absolute value of of something right um so given that we can then sort of start thinking about okay so if i want to make a triangle 
[02:09:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7787) wave that is sort of repeating over some um over some range uh what if i take this value multiply it by two subtract one now it's going from 
[02:09:59](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7799) negative one to one over this interval and then if we do abs of that value you can see that it's now bouncing from one to zero to one 
[02:10:08](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7808) so now we have a triangle wave inside of the zero to one range right so so now it's just a very simple mathematical function to do this and obviously we can we can repeat this 
[02:10:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7820) so so if we then go back here and we we have our coordinates here and we uh we first multiplied by some value let's say five and then we do 
[02:10:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7832) frac of that so if we go back uh we now have five repeating sections of zero to one right and then we want to try to turn it into a um try to turn it 
[02:10:43](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7843) into a triangle wave so then we can do the same thing that we did here right absolute value of x times two minus one 
[02:10:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7851) um so all right so we take this multiply by two subtract one and then we take the absolute value of that whole thing uh and then if we go 
[02:11:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7861) back to unity we now have a triangle wave so this one is now going from zero to one and then down to zero again then up to one again and so forth and 
[02:11:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7870) you can do this in many different ways you also have the the trigonometric functions uh so you don't have to do waves uh like manually like this 
[02:11:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7878) um you could also do the uh let's say you do the the cosine of this value uh because as you know uh trigonometric functions repeat themselves 
[02:11:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7890) so if we do cosine of x in this case we did times five uh it's not going to repeat that many times because uh the circle constant is involved 
[02:11:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7900) um but we can just throw some constant in there let's say 25 go back to unity we now have a repeating pattern although this one is going from negative 
[02:11:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7908) one to one because that's what this one outputs right should we involve tau um let's do it things juggle for the tau value all right define tau 
[02:12:02](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7922) that number there we go this is a preprocessor defined uh basically makes it so that any instance of this is going to be directly replaced by this 
[02:12:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7933) you can define things as like names of stuff and like you can make macros you can go kind of crazy with like preprocessor defines in this case i'm just going to define 
[02:12:23](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7943) that as the constant um yeah so so now if we do this coordinate times tau and then an integer value this is guaranteed to repeat perfectly 
[02:12:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7955) and seamlessly it's going to start and end on the same value so this guarantees that we're going to go through an entire period yeah so now if we go back here starts at 
[02:12:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7966) 1 goes down to negative one goes back up to one and so forth and this thing of like remapping from negative one to one to zero to one or vice versa 
[02:12:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7975) is something that like i tend to do a lot after a while because it's very common to both like juggle these two ranges um so in this case i would multiply by 
[02:13:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7984) 0.5 and add 0.5 so that kind of shifts the range that this is in so now it's going from 1 to 0 to 1 to 0. freya's just having fun now yes i had to 
[02:13:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=7996) kill time for 10 minutes uh before lunch but i also wanted to show that like um as soon as you start like harnessing this type of like math 
[02:13:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8006) stuff you can do a lot of like fun things with this um and you can animate this if you want to it doesn't have to um you don't have to like have static things you can do it in 
[02:13:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8017) different spaces it doesn't have to use uv coordinates and so forth um there's a lot of stuff you can do with this but i feel like we should explore that 
[02:13:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8024) after after the break uh so so we're we're doing a lunch break all right so is there anything you would like me to recap or 
[02:13:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8034) talk about that we've already talked about or clarify something if so do let me know can we do a quick one minute recap yeah okay i can try to do a quick one i tend to make 
[02:14:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8044) them way too long but let's do a quick recap of the shader that we wrote at the very least because i'm guessing that's the one that has this most information dense all right so 
[02:14:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8052) it's as you like recap the structure of a shader um the shader itself um it's kind of the outermost scope here uh this is the path to the shader when 
[02:14:24](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8064) you select a shader i didn't mention that before but basically if you have a material you can select between different shaders so the path to where the shader lies in 
[02:14:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8076) this in this whole group uh depends on the path you have at the top of your shader you can sometimes be useful useful for like categorization and stuff 
[02:14:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8085) all right and then we have the properties and the properties is basically all the stuff that individual materials can modify and have as input data for this shader 
[02:14:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8096) so generally all the properties that is stuff that you can tweak with this everything else is hard coded pretty much there are some exceptions there are some 
[02:15:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8105) things that are populated by unity the mesh data is populated by unity and so some of the positional stuff like the transform matrix uh the mvp matrix 
[02:15:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8116) uh like light information is also supplied by unity automatically but basically all the custom stuff that you generally want to input to your shader is defined by the properties 
[02:15:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8126) all right let me know the sub shader um most shaders that you're going to write are only ever going to have one sub shader but if you want you can you can have 
[02:15:33](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8133) several sub shaders in a single shader file which you can then select between depending on like performance characteristics or whatever 
[02:15:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8140) um using the the uh level of detail the thingy um i don't know how that works i never use it it's probably not relevant um there you go 
[02:15:50](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8150) and then you got the watch tags so these are the configurations for how you want this sub shader to act uh there are sometimes also tags here this is usually called pass tags 
[02:16:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8161) um and then you have sub shader tags uh it's important to make a distinction between these because it's easy to get them missed like mixed up where you like try to 
[02:16:11](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8171) enter subtitle tags in the past tags um so it's important to like know the difference between the two um so but i can easily you can easily do a google 
[02:16:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8181) of like unity shader pass tags and if you go here you can then see okay what are the the value like the the valid tags we can have in and 
[02:16:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8192) in our in our past um and so forth so so you can just google any of these things and you're going to find it all right um is there a way to see all shader paths 
[02:16:41](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8201) including hidden shaders um with the reflection i think there is but i don't know if there's a way to do it in unity um just with the vanilla editor and will we go over transparent and opaque in the 
[02:16:52](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8212) order in which things render and such yes okay and then we got the cg program which is the same thing as hlsl code so what's within the cg program and ncg 
[02:17:02](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8222) scope is uh code or shader code everything outside of that is just called shader lab it's unities like wrapper language to encapsulate all 
[02:17:11](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8231) the data we need to supply and interact with our shaders all right so and then in in the past is where we define our shader code so 
[02:17:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8242) in this case we have a vertex shader we have a fragment shader we include some of the unity like built-in variables and stuff uh we define tile because tao is useful 
[02:17:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8252) and then we've got our properties defined as variables and we need this in order to be able to access them all right this is a little messy i don't know if i should remove the comments or 
[02:17:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8260) if it's going to be actually let's leave them in so this is the tangent direction x y z and the tangent sign on w it might be useful to say that all of 
[02:17:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8277) this is local space as well so this is the data you get from the mesh um so so the mesh data is the input to the vertex shader so this is 
[02:18:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8289) where we have all the information that is encoded and all of the vertices right um and there are only like a limited number of things you can do here 
[02:18:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8298) i've already listed like the things i will use 99 of the time uh sometimes i will use like further like uv coordinates from this 
[02:18:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8307) but generally uh the things that i've listed here is like pretty much what you're gonna use um all the time um i think there are some extra stuff you can get out of this 
[02:18:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8318) um like especially when it comes to like skinning i think you can get like bind poses and whatnot but that gets into stuff that i haven't touched ever 
[02:18:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8325) so all right so so mesh data here we define what inputs we want to take from the mesh that we care about in this shader in this case we wanted the local space 
[02:18:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8335) vertex position the local space normal and the uh the first uv channel which is uv-0 because most most meshes have some form of uv coordinates defined 
[02:19:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8346) all right so this is then we're going to skip over this because the mesh data then goes into the vertex shader and the vertex shader's job is to supply 
[02:19:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8358) data to the fragment shader and set the clip space position of the vertex we set the clip space position here and then we use another structure called 
[02:19:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8366) interpolators that is going to be data that we want to pass to the fragmentator so we set up an interpolator struct we supply data to this tract and then we 
[02:19:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8376) return the struct and then we're done with the vertex shader this struct itself uh we can the the only uh thing that you always have to have there is this one 
[02:19:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8385) you always need to set the sv underscore position uh which is the clip space position of each vertex everything else that follows here can be 
[02:19:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8394) whatever you want um like you can you can store data in um like maybe maybe this one is a it's an interpolator you use to store i don't know some length properties or 
[02:20:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8406) something it could be even separate things for x y z w uh like this can be anything and they're always in the same uh they always use the semantics text 0 
[02:20:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8415) 1 2 3 and so forth not to be confused with these text chords which explicitly refer to uv coordinates but in the interpolator structs 
[02:20:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8427) they're basically just channels where you want to send data through right okay so after you set the interpolators the um you have now 
[02:20:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8437) set data for each vertex and the java the fragment shader is to render the triangles right because now we're going to render actual pixels to the screen 
[02:20:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8447) and all the data you have in each corner of the triangle is going to be blended or interpolated across that triangle it's not only colors it's normals and it's all the data that you pass in there 
[02:21:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8461) um so so if you pass in a value of one into an interpolator and you pass in a value of two into the interpolator uh the pixel that's going to render here 
[02:21:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8473) is going to have a value of 1.5 right because it's a halfway blend uh between uh oops because it's a halfway blend between one and two right why do you need text 
[02:21:25](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8485) code zero etc in the interpolator if you set the value the interpolator struct variables in the vertex shader what do you mean by why you need it oh um 
[02:21:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8494) so i i think it's just because it's the way things work i don't think there's any specific reason um oh sorry this one apart from you want to be able to 
[02:21:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8504) distinguish between which one is the clip space position and which one is just data you want to interpolate or at least that's how i interpret it 
[02:21:52](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8512) um so so like this is just a way to enumerate all the data that you want to pass um and the fact that it's called tax card is just a happenstance right 
[02:22:02](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8522) i wish you didn't have to specify this uh because it feels kind of superfluous i wish you could do this and then everything would just work uh but that's not how how shaders 
[02:22:11](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8531) are structured um yeah so usually you just it's just a thing you have to add pretty much it's annoying boilerplate right so the thing we did in the vertex 
[02:22:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8540) shader apart from getting the clip space position uh was that we also transformed the local space normal to world space um this was so that we could 
[02:22:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8551) output this in the fragment shader oops uh where did i go i fumbled my case too much so if we output that that would be i dot 
[02:22:41](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8561) normal and then whatever value in the alpha channel um so now we're displaying the normal uh direction and since it's world space the orientation of this object is not 
[02:22:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8574) going to affect the uh normals that we're seeing here right and then the fragment shader itself is relatively straightforward fragment shader is usually the one that is 
[02:23:02](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8582) um the most straightforward because you're not passing anything to anything you just have data and you want to output a color that's kind of all you're doing 
[02:23:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8592) so we were before we went for break we were looking at generating patterns and waves uh in a shader so in this case we were generating this over the uv 
[02:23:23](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8603) coordinates the space and we just limited it to the x component of the space right um yeah so in this case we're doing a wave over the x components 
[02:23:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8614) but we could do this over like both components as well uh we could make this a float too um because all of the built-in functions just work with any number of components 
[02:23:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8626) uh what's going to happen is that for the most part it's going to do the same operation for every component um so if we make this a float 2 then it's going to do this on both axes 
[02:23:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8637) and and visualize it with red and green so now uh where we have a cosine wave on the x-axis as well as on the y-axis and we're visualizing them separately 
[02:24:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8649) using the red channel and the green channel um so like you can you can juggle these channels very easily back and forth anyway so let's go back to using one 
[02:24:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8661) [Music] um okay let's repeat this a few more times let's do five there we go um so 
[02:24:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8676) one thing that is very nice in shaders in in the way the shaders work and that you're kind of just piping math in different directions um is that it's very easy to change the 
[02:24:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8686) domain in which this is happening so for instance we have this value changing by the x coordinate of the in the uv space right 
[02:24:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8697) so the orientation and the position of this object doesn't matter because it's all in uv space uh but we could do this in world space if we want to right there's nothing 
[02:25:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8707) stopping us from doing that and and like likewise you can change this to the the y coordinate and everything is going to quote unquote just work 
[02:25:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8714) um the only input we have to this right now is that we we have a single value going from zero to one and then the math formula can sort of 
[02:25:23](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8723) work its magic and that is going to make a wave along that right and and this has all sorts of implications but you can you can very easily get 
[02:25:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8731) like pretty funky effects with very simple modifications um so for instance let's say let's say you want to make this wave uh wiggle for instance you want to 
[02:25:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8740) make this wave let's see if we go back here let's say we want to make this one have a way where it's distorted in one direction 
[02:25:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8748) uh well distortion means i want to offset it in one in a specific direction right uh so let's say we make a um an offset here so let's call it x 
[02:25:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8758) offset or something and then maybe we want to offset this based on where it is vertically right that's where we want this offset to be 
[02:26:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8766) different along um so uh we can do i dot uv dot y we could just leave it at that if we want to then we want to offset the coordinate 
[02:26:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8778) here so plus x offset there we go so if we go back now now we have a diagonal wave because what we're doing is we're adding a value 
[02:26:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8788) as we go higher on the y scale we add more and more in a specific direction um so now it basically became a diagonal thing and this looks like 
[02:26:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8796) some sort of drill now uh so if you want to make a drill um you got the shader code right there um but 
[02:26:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8804) you know what if we do stuff like uh what if we make this with a with a some trigonometry right uh what if we do the cosine of this uh times tau times eight for instance 
[02:26:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8816) uh then multiply that by 0.1 probably and then go back now we have the zigzag pattern right uh we can maybe modify that a little bit further 
[02:27:08](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8828) make it a little bit less intense there you go so now we got this wobbly pattern isn't that neat the thing i really like about this is that it's like it's so 
[02:27:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8838) like nice to be able to just directly visualize the math that you're doing and i think it's really neat and then you can start like making the effects out of this right 
[02:27:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8847) let's see what could we do with this um let's say we want to make this animated for instance uh then we want to animate something we can just very easily access a time 
[02:27:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8858) variable so unity has a built-in time variable called underscore time and this one is again automatically supplied by unity i'd say 
[02:27:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8867) it's a global variable in shaders and um it has xyzw components uh it's a little it's a little esoteric but basically the x y z w components use different 
[02:28:02](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8882) scales of time so the y component happens to be seconds but the w component is like seconds divided by 20. so if you want to have like different 
[02:28:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8893) speeds you can use different components of this or you can just multiply it um so if we want to change um the opposite here we have the x 
[02:28:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8902) offset here but then we can add time to this so if we do underscore time dot y we're now going to add the the current time in seconds 
[02:28:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8911) to this so now if we go back to unity and make sure that animated materials is enabled there we go that looks very trippy 
[02:28:42](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8922) so let's slow it down a little um there you go so now you can see that we got this little pattern that's animating over time right 
[02:28:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8937) isn't that neat i have to like rotate the camera because for some reason it's like frame rate limited to a really gross frame rate i don't know that weird 
[02:29:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8945) anyway um yeah so so these are just like some of the things you can do relatively easily in shaders and like like we talked about before if you go to like if 
[02:29:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8956) you want to make vfx and stuff like that where um maybe you want to have a ring around uh the ground or something like that actually we can just do that 
[02:29:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8966) like we can just do that so let's say we have oh maybe we can do that actually i don't know what the uv coordinates are in this thing 
[02:29:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8974) um so let's say we want to make some sort of vfx thing first i'm going to reverse this so that we're on the other axis i want to reverse the direction of this 
[02:29:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8985) so all we need to do is negate time we could hit play but i don't want to like i don't want to mess up the play states um so if we uh negate the time we're 
[02:29:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=8996) gonna it's gonna start moving in the other direction right uh all right let's scale this a little bit all right so maybe this can be like something 
[02:30:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9005) that's like a ring around a player like an effect or something um and then let's see if we want to want to make it like fade out 
[02:30:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9013) um because we don't want it to be fully visible at the top we want it to be a ring along the ground that then fades out the higher we go so then we need a value that is changing 
[02:30:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9022) along that axis and again the way that you debug things and shaders is that you usually just output some value so i think the the y-coordinate of the 
[02:30:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9032) uvs yep that one goes from zero to one we can use that to then tweak the way that this pattern looks across that space 
[02:30:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9040) right um so what we can then do um in this case one easy way of making this fade out to say black is that we can multiply by it right 
[02:30:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9051) um because if you multiply by a low value it's going to start getting more and more suppressed toward black if you multiply by one it's not going to change at all 
[02:31:00](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9060) so if we then take this t value we can then do t multiplied by the y coordinate so now it's going to fade right although it is fading in the wrong 
[02:31:11](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9071) direction so we might want to reverse this so we have 1 minus that uv coordinate and now we have this feeding effect from the ground right 
[02:31:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9080) um we haven't done anything related to blending yet so we probably want this to be additive or something so we could go into that if you want to 
[02:31:29](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9089) i don't really know if we should move on to like lighting or if you want to like learn about blending already uh is it cheaper to 
[02:31:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9096) make a thing selected color change with a shader rather than switching materials it depends um but you can you can do either it doesn't really uh i don't think it's gonna matter that 
[02:31:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9107) much uh all right let's do blending in that case okay i'm just gonna ignore the caps of this because i don't want the i don't really care about the caps 
[02:31:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9117) so let's look into blending let's say that we want this to actually go into uh looking more like a like vfx type of thing uh then right now there are a lot of 
[02:32:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9126) things that are wrong with this right we can't see anything behind this even if we have something here it's going to fully obscure whatever object is sitting behind it 
[02:32:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9136) um so right now we are rendering this fully opaque as in there is no way we can have anything close to something related to transparency in this at all right now 
[02:32:29](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9149) uh so one of the first things we need to do is think about blending and blending is a little bit weird in the way that it's set up quick little explainer 
[02:32:39](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9159) okay so when you have a shader like this you get a color out of the fragment shader right this color that you're getting out of 
[02:32:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9168) the shader in terms of blending is called a source color so that's usually shortened as src and then you have the background as in 
[02:32:59](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9179) the destination that you're rendering to and that is whatever is already behind the object so that is usually shortened as dst as in the destination and 
[02:33:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9193) the way the blending is set up in shaders or as in the the very cheap version of doing blending that doesn't require extra render targets there's a term for 
[02:33:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9202) this i just forgot what it is uh oh the back buffer blending um anyway so the way that this works is that you have source uh times uh some 
[02:33:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9214) value here i don't know what to call it um let's call it a there we go source times a um and then it usually is plus but it can be minus as well and it can 
[02:33:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9228) be reversed minus so it's source times a plus or minus the destination color times b so when you define blending as in you want to change the mathematical formula 
[02:34:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9243) that determines how this is going to blend with the background the things you can modify is a right here and b and 
[02:34:17](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9257) you can modify this operator so how can we use these alpha colors or the shader to apply textures or colors up on them we're going to get the textures later 
[02:34:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9267) for example replacing the white with a texture and a black with another yeah we're going to look into textures later but not right now is there time to talk about 
[02:34:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9276) pre-multiplied alpha i don't know if i want to go into that it's so frustrating every time i talk about that on twitter i always get some extremely frustrating 
[02:34:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9287) person who has dedicated their life to reading about pre-multiplied alpha and then they're like taking their time to nitpick about how i use some term 
[02:34:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9294) incorrectly and like pretends that i don't know what i'm talking about and it's just really annoying um anyway i shouldn't let that affect 
[02:35:02](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9302) y'all i don't know if it's gonna matter that much in this case uh it might be worth mentioning but um okay so so the way the blending works 
[02:35:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9310) in shaders is that you need to to set a this operator and b in order to get the effect that you want right that is kind 
[02:35:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9320) of what you have to work with uh so this is again this is the blending okay so with this in mind uh you can then uh do different things so let's say 
[02:35:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9334) that you want to do additive blending so we got additive okay additive blending uh additive blending is the one that i was showing earlier that kind of makes 
[02:35:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9345) things brighter usually um so if we got um it basically takes the background and you just add to it straight up add mathematically equivalent to just adding 
[02:36:00](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9360) so in this case you can see that if you have additive blending it kind of just adds light to it it doesn't darken anything in fact um it's completely incapable of 
[02:36:11](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9371) darkening uh unless you have negative values i guess additive rendering is very useful for like um flashy effects uh like light effects 
[02:36:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9380) and whatnot it's very very commonly used for like i don't know fiery uh things because you usually get these nice little orange ingredients and whatnot 
[02:36:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9390) out of it that people usually want to have when doing like flame particles and whatnot so this is additive blending um and i just totally drew that on top 
[02:36:42](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9402) of everything else all right so additive blending if we look at this formula what can we do to make this formula just be source plus destination uh 
[02:36:50](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9410) well all right we shouldn't be an additive anymore there we go so we want to do that then all we need to do is set a to one so that needs to be set to one 
[02:37:00](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9420) the operator should be plus and b should be 1. um and that's it that's how we get additive blending because then what's going to happen it's going to take the 
[02:37:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9430) source color which is this shader and source multiplied by 1 is just the same thing as source plus the destination multiplied by one which is just 
[02:37:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9440) destination so that becomes source times test or source plus destination that's how you do additive blending very straightforward okay and let's see 
[02:37:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9450) what else do we have we have a multiplicative blending so usually it's called multiply so so if we want to multiply these colors we want to have 
[02:37:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9460) a source times destination in this case uh what we need to do is we need to set a to destination and we set b to zero 
[02:37:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9475) so what's gonna happen then is that it's gonna shove in the uh the destination caller here into a so with source times destination uh 
[02:38:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9485) and then we do plus destination times 0 which then just removes this factor entirely so so sometimes when you look at blending modes it's always important to 
[02:38:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9498) read them in this structure because when you look at a shader all you're going to see is this you're not going to see anything in relation to like additive or multiply 
[02:38:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9508) or alpha blended all you're going to see is the words one and one because plus is usually the default uh so if we go back here 
[02:38:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9518) then blending modes is defined in the pass and there before the actual cg program program happens because it's not in the actual shader code it's in 
[02:38:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9528) shader lab right so the way you define blending mode is you type blend and then you enter your a and your b things and in this case you want one and one 
[02:39:00](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9540) uh they're always in words you cannot enter custom formulas here there's a very specific set of things you can supply here but this basically means that it's additive 
[02:39:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9550) um then we can add the other one just for uh for completion uh we have multiply there uh so that one would be a dst color 
[02:39:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9561) would be the destination color and then zero so this would be multiplicative or multiply but we're gonna try to do additive in 
[02:39:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9571) this case okay so let's see what this looks like it looks like it's sort of additive but we now have a separate problem as soon as you start getting into things 
[02:39:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9584) that are transparent you run into the issues of the depth buffer or whether or not you should write to the depth buffer 
[02:39:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9594) um so if we add a regular unity uh sphere um you can see that it sort of kind of works but it's also got some sorting issues and whatnot right 
[02:40:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9606) um so the problem is that the this one is currently writing to the depth buffer and the depth buffer uh there's a lot to go into in the depth buffer but it's kind of just a 
[02:40:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9618) big screen space texture where some shaders write a depth value which is between 0 and 1 and when other shaders want to render they check this this depth buffer to see 
[02:40:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9632) is this fragment behind or in front of the depth buffer and if it's behind the depth buffer it will not render so so basically what's happening is that 
[02:40:43](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9643) we we have our camera there we go and then we're writing to the depth buffer with some object here right and what that means is that this is basically gonna 
[02:40:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9656) make the depth buffer go from the far clip of the camera and then it's going to have values that are really close to the camera because we wrote to the depth 
[02:41:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9664) buffer here right so it's basically going to create this little cone in the depth buffer and so then if we want to render something behind this object 
[02:41:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9674) it's going to skip this it's going to detect that well since we already have something in front of it we're not going to render this but whenever you draw something 
[02:41:23](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9683) transparent we can't just write to the depth buffer like this this method works for opaque objects things that are not like partially transparent 
[02:41:33](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9693) but as soon as you have something that can still show the destination color we need to make sure that it doesn't write to the depth buffer 
[02:41:41](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9701) so so in this case we want this one to not write to the def buffer uh so then what's going to happen is that our transparent thing is going to render 
[02:41:49](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9709) and then maybe the opaque thing that's behind it is then going to write to that depth buffer instead so it's not actually going to affect the uh or 
[02:41:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9718) additive object right here did that make sense it's a little technical but you generally don't have to care that much about how the depth buffer works apart from the fact that 
[02:42:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9727) it's there to be able to uh optimize out things that are behind things right it's not a draw that is skipped right no the draw will still happen but the fragments will be discarded very 
[02:42:19](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9739) early uh even before your fragment shader hits um yes so so it's it's a very good optimization in that sense because you skipped the fragment shader entirely 
[02:42:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9748) but yes it will not not have like anything in relation to like occlusion calling uh it's only like a rendering feature uh there are many ways that you can like 
[02:42:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9757) play with the depth buffer and there are basically two things that you can do with regards to the depth buffer where you can change the way that it reads 
[02:42:49](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9769) from the depth buffer and the way that it writes to the depth buffer would that mean that it's kind of heavy to render multiple transference objects in front of each other at the same time 
[02:42:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9778) yes the thing about rendering multiple things in a stack with transparent objects is that let's say you have let's say 
[02:43:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9786) this is the camera again and you have a bunch of planes that all have like some additive texture or whatever because it looks cool um what's gonna happen is that the the it 
[02:43:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9796) has to render every single one of these it can't skip any of the fragments um so if you're not careful uh you can run into situations where you start lagging in some games this is 
[02:43:29](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9809) actually noticeable if you you like um like this is pretty common in particle effects if you make like large smoke particles 
[02:43:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9817) then usually you would have this like large nest of like quads and all of them have these like large cloud textures on them right and so so 
[02:43:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9827) like especially in older games sometimes if you walk into like a particle effect with large clouds your frame rate will just tank completely because these are covering a 
[02:43:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9837) large portion of your screen and it means that it needs to do like full screen renders of all of these quads right but if you're far away uh then if your 
[02:44:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9846) camera is over here or something then it's totally fine it doesn't matter because it's like it's a tiny amount of pixels but if you get really close then you 
[02:44:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9853) have so so many layers to render uh this is called a fill rate if you if you want to have a technical term for this concept so you want to be careful to not have 
[02:44:24](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9864) too high of a fill rate so what's happening here is that this one is writing to the depth buffer but we don't want it to there's also um i don't know maybe 
[02:44:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9874) it's going to be an issue we'll see so that is the right whether or not we want this to write to the depth buffer and we want this to be off 
[02:44:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9884) let's recompile and now it seems fine you might now notice though that we have a separate problem that this one is being rendered before the sphere right uh so because we want 
[02:44:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9897) this one to be rendered afterwards not before so what what's happening is that this one is now writing to the depth buffer and just overriding um 
[02:45:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9906) everything we're drawing here um so in unit is built in render pipeline the uh basically there's a an order in which different types of geometry tends to render uh so 
[02:45:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9920) opaque is or actually the first thing that renders it's a skybox second thing is opaque or it's called geometry in the in the render queue and then you have a transparent which 
[02:45:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9930) you usually group like all additive and transparent stuff in and then after that you have like overlays like flares and like lens flares and stuff tend to go 
[02:45:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9938) above everything else um yeah so that's usually the render order um so when you're dealing with transparent stuff usually you want to 
[02:45:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9946) set the render type to transparent uh and you also want to set the render queue so render queue uh should also be set to transparent 
[02:46:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9963) uh both of these relate to the draw order or actually it's mostly render queue that doesn't render type is mostly for tagging purposes for post process 
[02:46:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9972) effects um a render queue is the actual order that things are going to be drawn in all right let's go back uh that did not work so let's go to unity 
[02:46:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9982) unity render not that one [Music] oh it's called q rip there we go q transparent 
[02:46:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=9997) recompile there we go so so now we're drawing this additively and it seems like everything works so far as if we copy this uh you can see that they sort of uh they 
[02:46:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10007) all render they don't obscure each other and they sort of add together to make this very glowy glowy thing right so one thing we might want to do 
[02:46:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10015) on this is that what if we want this to be double-sided because we kind of don't see the other side of this we just have one side and but the back 
[02:47:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10024) faces are just gone right this is something called back face culling and back face calling is the default behavior of when you're rendering shaders in 
[02:47:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10035) unity and basically you can tell your shader to either render back faces or front faces or both so if you say call back 
[02:47:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10048) this is the default value this means that it has backface calling culling usually means that it's a removal of something you can set that to cold front and now 
[02:47:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10058) it's going to flip so now it's not rendering the front side of the triangles and it's only rendering the uh the back side uh but if you want to 
[02:47:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10067) render both you can say call off that means it's rendering uh both sides of the whole thing so now we even have the front side of it uh 
[02:47:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10078) okay why do you have q and render type together in both set to transparence so render type is basically a tag to inform the render pipeline of what type this is this is usually used for 
[02:48:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10092) post-processing reasons this does not actually change the sorting but it's a useful tag for post process effects this one changes the render order 
[02:48:24](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10104) so unity has a bunch of preset categories um so there's uh skybox opaque transparent overlay and so forth and these are all 
[02:48:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10114) rendered in that specific order uh we want to render all of our transparent objects after everything that's opaque has rendered 
[02:48:43](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10123) because we don't want the depth buffer to write depth values um that's going to destroy all of our like transparent and additive effects um so we want to make sure that 
[02:48:53](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10133) everything that is transparent or additive or multiplicative all of that we want to render after everything opaque has rendered so 
[02:49:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10141) that's why we set the queue to transparent okay so this looks kind of neat i don't like the fact that we have the upper and the lower part 
[02:49:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10149) rendering uh we can sort of hack that away uh multiplying t by um what's what's the thing i dot normal dot y 
[02:49:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10162) or the abs value of that is greater than o point something there we go um no less than now i just hacked away the those two 
[02:49:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10176) surfaces um basically i'm using the normal of the surface and if that vector is pointing either almost entirely up 
[02:49:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10186) or almost entirely down um i multiply by zero to just remove uh to remove those things it's a little hacky but you know what that's that's how shaders do okay what 
[02:49:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10198) else do we want to do with this yeah i think this sort of illustrates my point of like um that you can use all sorts of patterns to create these types of effects right 
[02:50:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10206) uh where you want to have some sort of highlight circle around some objects in fact let's put an object there there we go this is now marking the the holy 
[02:50:25](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10225) holy sphere i feel like there was something else i was going to talk about when it came to blending oh there are other things you can do when it comes to the depth buffer 
[02:50:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10234) so while this effect shader no longer it no longer writes to the depth buffer but it still reads the depth buffer because if we make this one intersect the sphere 
[02:50:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10247) you can see that these pixels here are not rendering right that is not something that always happens sometimes you want to disable that 
[02:50:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10256) um so on top of z write we also have the test for whether or not over how the testing should work out when you're presented with a depth 
[02:51:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10265) buffer with some value right the default value is called l equal it's a little esoteric but it basically means that if the depth of this object 
[02:51:19](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10279) is less than or equal to the depth already written into the depth buffer show it right otherwise don't so so l equals the default value uh if you want to um always draw 
[02:51:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10294) you can set it to always so now even if this is behind the sphere it's still going to draw it doesn't care about the depth buffer whatsoever you can also reverse it you can set the 
[02:51:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10306) z-test to greater than or equal in this case it's only going to draw if it's behind something and it's not going to draw if it's in 
[02:51:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10315) front of something this one is super useful if you're doing stuff like uh if you have a character effect where you want to show like a ghostly version of a character when 
[02:52:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10325) they're behind something then it can be useful to have two shaders that one of them renders when you're behind something one of them when you're in front and 
[02:52:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10333) then so even if you're partially obscured you can see both versions of it um so you can do all sorts of hackery with the depth buffer 
[02:52:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10340) um but yeah in this case usually you want the default value of less than or equal is there n equal to um i don't don't know if equal and not 
[02:52:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10352) equal are ever going to be useful because there's only a sliver of infinitesimally small intersections where that would be um like where that matters right 
[02:52:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10364) because that would only mean that where they're exactly the same it would either show or not show right uh which only happens at very very few locations 
[02:52:53](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10373) but there might be um yeah if you search for it you can probably find it i just never use it myself yeah the the ones that are like there are things you have for like 
[02:53:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10381) there is less than equal or less and the difference between the two can be useful if you want to prevent z fighting uh but other than that i don't really know what the 
[02:53:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10390) what the use would be of an equal or not equal um um okay do we still have the colors we do okay now that we have this whole thing uh we 
[02:53:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10406) can still use all of this uh with our colors right uh so let's make a new variable just for readability let's call it waves uh 
[02:53:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10417) float uh top bottom remover there we go that's this one based on the normals um okay let's say that we now want to bring 
[02:53:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10434) back our colors we want to set a color at the top of this and a color at the bottom of this let's call this um gradient we're going to base this off of the uv 
[02:54:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10447) coordinates y component so we could just return this gradient to show what it looks like so this is the gradient 
[02:54:17](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10457) we have color a is at the bottom and then we have b at the top so i've said that the black fading out because black doesn't change anything with additive 
[02:54:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10468) uh rendering right okay so maybe uh let's see color a would be the bottom let's make that uh some sort of cyan and then the top one some more blue stuff 
[02:54:43](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10483) there we go okay and then what we might want to then do is multiply this by waves and now we got got waves with some colors right uh we have some colors at the bottom it goes 
[02:54:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10497) from like cyan to more of a darker bluish tone there and so like everything you're doing pretty much is just manipulating math and colors and vectors in order to 
[02:55:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10510) get these types of effects that you want um and again you can range remap everything if you want to change the contrast of this or the fall off of this all of this stuff is really really easy 
[02:55:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10522) and straightforward to change once you know the math behind it so you do kind of need to know a lot of math to do this stuff but once you like harness that you can 
[02:55:29](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10529) make like almost anything it's it's wild how much you can do if you know how to write shaders um so i know that it's like empowered me and all the projects i worked on a ton 
[02:55:41](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10541) um so it's super super useful okay let's see which thing should be covered during that hour emission would be cool emission uh 
[02:55:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10551) depends on what you mean by a mission uh in some sense everything you've been doing is just emission because like none of this is affected by lighting 
[02:56:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10561) none of this is shaded as in we have no shadows on anything so usually when you talk about emissive shaders this is what you're talking about as in 
[02:56:11](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10571) uh shaders that are unaffected by uh shadows right but if you want to get stuff that like uh if you want a bloom effect or something like a 
[02:56:19](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10579) post-processing thing that's usually a post-process effect and not something you make like localized on objects in the world um yeah so kind of depends on what you mean by emission can 
[02:56:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10590) we get some wavy effects perhaps isn't that exactly what we've been doing oh distortion like it's easier once you have textures but we haven't gone through textures yet 
[02:56:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10600) oh yeah vertex offset that is something we should definitely talk about let's talk about vertex offset i was going to talk about that earlier that i forgot 
[02:56:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10607) so i'm really glad you brought that up all right vertex offset there we go paste the existing code called vertex offset let's create a tessellated plane 
[02:57:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10623) what a beautiful plane if you're working with shaders in unity this color you're gonna see this color a lot okay so i have a plane here this one is 
[02:57:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10635) tessellated so i've like subdivided it into a lot of different triangles which means that we can deform it because we have a lot of geometry to 
[02:57:23](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10643) uh to deform with right all right so let's make a material out of our vertex offset shader material there we go it is completely invisible 
[02:57:39](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10659) so let's modify this one uh let's first just output the uh vertex color or the the uv coordinates sorry okay i don't want this one to be 
[02:57:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10676) additive so uh we're just gonna default all of this and we're going to set the render type to opaque 
[02:58:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10689) and the the default render queue is called geometry instead of opaque for some reason but kind of annoying thing to have to remember all right 
[02:58:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10701) look at this mango square okay let's bring back our uh wave along one of the axes and then um 
[02:58:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10726) remove this one so we just have the pure wave okay so here's here's a here's a neat thing you can do um so right now we've mostly been talking about 
[02:58:59](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10739) the fragment shader and we kind of just passed by the vertex shader which you quite often do you don't always touch the vertex shader you kind of just pass data through it 
[02:59:08](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10748) but let's call this a wave but a really powerful thing you can do in the vertex shader is that you can change the position of the vertices it can sound a little trivial like it's 
[02:59:19](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10759) not a big deal but if you consider the the number of vertices that we have in this mesh there's loads of them right there's in fact 
[02:59:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10771) 8192 triangles in this plane um that's quite a lot um so so like doing this in like on the cpu of like making a for loop iterating through all of these vertices 
[02:59:43](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10783) is going to be expensive um because the the cpu is kind of designed to be very specialized and very good at doing like advanced things that are 
[02:59:53](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10793) not like massive amounts of data but the gpu has sort of an entirely different architecture architecture where you have massive amounts of shader 
[03:00:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10804) processors that can do a lot of work in parallel and that's exactly what we're doing right we have a single shader program this is 
[03:00:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10813) the same code that is being run for all of these vertices right so now we have this really like parallel processing unit the gpu 
[03:00:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10821) where we can basically do all of this um it's almost free compared to doing it on the cpu um because this is so rudimentary and basic for the gpu to do 
[03:00:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10832) uh that it's it's it's really really powerful and this is also why sometimes the gpu is used for computing or processing data that is 
[03:00:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10844) unrelated to graphics just because the gpu is so so powerful at processing parallel data and and doing that type of math um anyway so it's a vertex offset so now 
[03:00:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10858) we're going to do we're going to add some code that can then change the position of the vertices so what we can do is we can take this wave 
[03:01:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10867) um and um how do you offload processing to the gpu you write shaders uh instead of doing your code that does uh whatever it is you're doing 
[03:01:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10878) do that on a shader um so like you you do that with shader code or compute shaders um and then you can get the data out of it usually it's like rendered to some 
[03:01:29](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10889) buffer or to some texture and that's how you get the data back okay so let's take this wave and just straight up copy this one to the 
[03:01:39](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10899) vertex shader so in the vertex shader we can paste in the wave let's see it's not happy with the uv and that's because the 
[03:01:49](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10909) we just have a different word for that it's called the uv0.y uh so now this one is reading directly from the mesh data instead of the interpolators 
[03:01:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10917) because now we're on a per vertex level right this is for each vertex not for each pixel or fragment um so now we have the same cosine wave here 
[03:02:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10929) and then let's use this wave to modify the y-coordinate of the vertex so v dot vertex dot y um equals wave 
[03:02:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10941) and in this case we can actually just leave the negative values in there so we can just remove the remapping there so now we have this wave parameter uh 
[03:02:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10950) that we're mod we're setting the uh local space vertex y-coordinate to before we transform it to clip space 
[03:02:39](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10959) uh and then if we go back to unity uh we have this insanity and this is because the waves are huge right now we haven't said how we haven't like set 
[03:02:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10968) the amplitude of this um so the amplitude is right now one meter so that's why we're getting this um interesting pattern um so we could add a parameter for that uh 
[03:03:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10981) wave amplitude and we did i probably want that to be like from 0 to 0.2 or something 
[03:03:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=10995) and then we need a variable for that so wave amplitude and then all we need to do is is multiply this wave by the amplitude there we go all right so now we got this 
[03:03:29](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11009) wavy looking thing we can set the wave amplitude if we want i want to make it a little softer um you can also press play to make unity not 
[03:03:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11018) run at like 24 fps uh now we've got now we got the very very rudimentary basic water shader right um and this is like 
[03:03:49](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11029) again this is basically free um if you think about the math that we have to do um it's very simple it's not that much math right we're just doing this very simple operation 
[03:03:59](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11039) um and we get this whole animation out of it do we have purlin noise next nope we might do we're to do noise with textures but 
[03:04:08](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11048) we're not going to generate pearly noise in the shader because that's generally a bad idea because it's very heavy so it's not very useful in games it's mostly useful if you're doing 
[03:04:17](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11057) shader toy stuff and you want to impress your friends with math but this is focused on game dev so all right and obviously you can do this like you 
[03:04:25](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11065) can still keep changing these things if you want like if you want to combine multiple waves maybe you have a wave 2 that runs on the x-axis instead and you 
[03:04:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11075) want this one to also play along with this then maybe you you have a wave 2 right there now you have a multiple wave system that is interacting and what 
[03:04:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11086) not right although the colors are a little misleading right now because the colors are still we didn't modify the fragment shader 
[03:04:53](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11093) we're just doing this in the vertex shader how do you ripple um acid like rippling from the center so if you want a ripple from the center 
[03:05:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11104) uh so you can consider the space that we're doing this in now right uh actually we should go back to the fragment shader for this it's a little 
[03:05:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11114) bit easier to visualize in the fragment shader um so now we're doing this animation where the domain is the uh linear x-coordinate 
[03:05:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11126) of the uvs of this mesh right so if we want to make this a radial as in based on the radius or distance from the center that is the input data we need for this 
[03:05:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11138) and right now we're giving it the linear y-coordinate so what we can then do is that instead of passing this in we can pass in the distance to the center 
[03:05:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11148) right uh so if we want to get that value um we can uh first we we can take the uv coordinates and remap that to a negative one to one 
[03:06:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11161) range in order to center it uh so if we just do uh if we look at the uv coordinates again 
[03:06:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11169) there we go you can see that we've got zero here uh oh this should be based on the x coordinate uh we've got zero here increasing on the y axis 
[03:06:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11180) increasing on the x axis um all the way from zero to one but we wanna put zero in the center right uh so then we do the exact remapping thing that we did before 
[03:06:29](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11189) where we uh remap something from the zero to one range to negative one to one range um which is a relatively straightforward transformation to do 
[03:06:39](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11199) you multiply by two and subtract 1 and now we've centered these coordinates where 1 is at the edge and negative 1 is on the other edge okay you can also use inverse lerp for this 
[03:06:53](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11213) if you want to you it's gonna be a little bit more descriptive with it um but it kind of depends on what you how you like want to structure your code and how 
[03:07:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11221) readable it is to you uh but maybe we can make a variable so float2 uv's centered okay and then if we want to turn this 
[03:07:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11236) into a radial coordinate um remember that these uv coordinates are vectors right they're vectors going from zero in the center out to some value 
[03:07:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11246) in this whole space so what we can then do is we can calculate a distance like a radial distance would be the length of this vector um is it magnitude no 
[03:07:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11264) length um so then we get the length of this vector and then we can output that um so go back to unity we now have a circular pattern because now uh every 
[03:08:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11281) pixel is showing the distance to the center so far so good i hope okay so now that we have this radial distance instead of using a linear coordinate we 
[03:08:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11293) now have a radial one that we can use in the same wave function we had before right um so 
[03:08:25](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11305) uh we got our wave and instead of using i dot uv dot x we can use radial distance here and then we go back and now we have um this very hypnotizing 
[03:08:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11317) shader there you go and that's sort of it and then you can do all sorts of stuff that you might want to do in terms of like oh maybe you want 
[03:08:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11326) to fade it out at some range if you want to make the ripples not go on forever then then maybe you want to multiply this so 
[03:09:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11341) that it ramps down as you get closer to the edges so what you can do is then you can multiply wave by uh radial distance although this is 
[03:09:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11352) going to have the opposite effect because the distance is zero in the center so now it's going to fade out the center uh but what you can then do is you can 
[03:09:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11360) invert that right one minus and then go back and now we have sort of ripples that fade out the further out you go um yeah um 
[03:09:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11374) okay so now now we did this in the fragment shader but obviously we can do this in the vertex shader too so let's see maybe we should make a 
[03:09:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11384) function out of this uh get wave um there we go now i get waved let's just make sure that this works 
[03:10:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11413) yep cool okay so now we can use the same function in the uh vertex shader although because this is a language like c and c is absolute garbage you need to 
[03:10:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11426) put the function before the place you use it and i hate it um so you need to make sure that the get wave is above anything you want to 
[03:10:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11435) any place you want to use it um all right so if you want to use that here then we wanted to do a v dot vertex dot y 
[03:10:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11447) equals uh get wave and then we pass the uv coordinates into that which is v dot uv 0 recompile okay so now this looks like a um some sort of uh tower of babylon or the 
[03:11:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11461) way that it's usually depicted i think or like a birthday cake um wait birthday cake this is a huge kink um so we want to multiply that by the 
[03:11:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11473) amplitude right that we had before fountain of wedding cake yeah one of those there you go so now you have this goopy three-dimensional wave of the generator 
[03:11:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11494) thingy okay although this one only goes above i feel like the waves should have they should have negative values um so let's remove this from the get 
[03:11:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11511) weave oh that's gonna get complicated actually if you want to use the same one for the you know what it's okay whatever they remind me um so i think it's better 
[03:12:08](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11528) to go through textures so that will also open up for more possibilities for uh the assignments i'm gonna give you um so let's do textures let's see let's create a new shader 
[03:12:19](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11539) unlit shader let's call it textured this is just going to be a gallery of very trippy shaders let's switch back to 
[03:12:29](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11549) another tesolated plane put it at zero move away these groups and supply our new material it's good it's called textured there we go 
[03:12:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11567) okay textures let's let's now jump into textures oh uh there we go okay first i'm just gonna murder these shitty brackets 
[03:13:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11581) a lot we don't care about uh pass we don't care about don't care about fog no fog no fog no [¬†__¬†] going 
[03:13:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11601) clutters up my shader okay cool uh the default state uh unity's unlit shader uh is that uh it actually already has a texture uh so 
[03:13:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11615) we can just kind of look at that to see how it works so you got a property just like any other property like colors and values and whatnot but you set it to 2d and that specifies 
[03:13:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11626) that this should be a 2d textures there are 3d textures and there are cube maps and all these work in a little bit different ways but in our case all we 
[03:13:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11636) care about is 2d textures main text is kind of the default name for unity's main texture property usually that contains the color information on the 
[03:14:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11645) surface all right so um pretty standard stuff when it comes to the rest uh app data would be the um mesh data uh and then v2f would be our 
[03:14:17](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11657) interpolators so the the thing that is new here uh is that um when we want to sample a texture you can see that we have the texture here 
[03:14:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11670) uh it's got it's referring to the main text variable which you need to define in order to be able to sample from a texture it's called sampler2d good to remember 
[03:14:41](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11681) i always forget and i always have to create a new shader and then check what it says in there um but yeah simpler 2d maintex this one is optional you know you don't 
[03:14:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11691) have to define this one but there as you might have seen in unity uh textures have this tiling and offset thing where you can set the tiling and an offset for 
[03:15:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11704) how that texture should be mapped that's what the uh what this is and this is sort of a magic magic variable name if you name it 
[03:15:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11714) exactly the same name as your sampler and add underscore st this is going to be the the scale offset um so this one is going to contain all of those values 
[03:15:25](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11725) um unity has a function called transform text and transform text basically takes those offset values and offsets some input uv coordinates 
[03:15:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11738) so all this is doing is that it's scaling and and offsetting the uv coordinates so that we can then get those scaled uv coordinates uh but this is 
[03:15:50](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11750) optional uh you can skip this entirely and just do v.u.v um in which case it's not gonna scale and this thing is not gonna 
[03:15:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11757) matter right um i almost never use the offset scaling values so usually i just remove that but in this case we might leave it in in case uh we want to tweak that 
[03:16:09](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11769) so what we got here is basically the same thing as before the same setup with the vertex shader and the fragment shader but there's a special function here 
[03:16:17](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11777) called text 2d text 2d means that we're going to pick pick a color from the texture and the input to this one is what sampler do we want to use when sampling 
[03:16:33](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11793) this or what texture and the other parameter is uh where do i want to get some colors from this so usually uv coordinates are used for 
[03:16:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11804) like exactly this purpose for sampling textures and the space we're working in for textures is from zero to one also sometimes known as normalized 
[03:16:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11814) coordinates um okay so so we are getting a color from this texture and then we're returning it and that's basically it um 
[03:17:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11824) so if we got this textured one we can pick a shader um let's do um let's do this this grass texture or moss texture there we go 
[03:17:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11840) so so now we are sampling from a texture and you can you can change the offset and tiling uh so tiling uh would would be used for scaling it or stretching it if you want 
[03:17:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11852) to um and so forth so so that's what the tiling and offsets values are for uh but again they're optional you don't have to use them 
[03:17:41](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11861) and you can also you do this manually the way that we did before right uh where we directly modify the uvs um so if we do something like oh.uv.x 
[03:17:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11871) plus or uh yeah plus equals um time dot y uh times 0.1 there we go um so if we now go back uh you can see that it's now scrolling 
[03:18:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11884) uh because we're literally adding to the uv coordinates which in in shaders would mean that it's offset right 
[03:18:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11892) um so so we now got this scrolling scrolling texture um useful for stuff like if you want to make a river or something usually you want to have like panning uvs 
[03:18:23](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11903) uh there are there are many many different ways you can modify uv coordinates to do stuff like that um you can even use textures 
[03:18:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11910) to modify the uv coordinates that you're then going to use to sample another texture it's kind of expensive to do that but you can use that for instance if you 
[03:18:39](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11919) want to have i know valve used this in portal 2 and in left 4 dead 2 where they were setting up like a texture 
[03:18:49](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11929) that would then be able to use um as a flow map as in uh that one would tell the shader what direction things should scroll in um and then it 
[03:18:59](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11939) had all sorts of shaded tricks to make sure that you don't get like infinite stretching and whatnot they were sort of like crossfading between different states as 
[03:19:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11947) you know a texture was flowing in some pattern um but yeah anyway um so you can do lots of stuff with modifying the uv coordinates and and you can map textures in almost 
[03:19:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11958) any way you want you don't have to use uv coordinates um this is a really really important thing and i think it's a shame that 
[03:19:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11966) like it's called text cord which almost feels like it's meant to be used for textures like uvs are texture coordinates um but i think that that is a that is a 
[03:19:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11976) thing you need to like make sure that you don't like learn because textures can use any coordinates from any space and across any time 
[03:19:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11988) and uv coordinates are not necessarily used for only mapping textures um in fact most of the work that i've done in the past like two years uv coordinates have 
[03:19:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=11998) nothing to do with textures i use that for passing data and like other information um so i think it's important to know that like quite often uv chord uvs can be used for 
[03:20:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12010) just passing data that is completely unrelated to textures and textures don't have to use uv coordinates even though that is very common of course 
[03:20:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12018) so just to show an example of this um so let's say we want to um you can name these things anything you like though right yes well not the semantics 
[03:20:29](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12029) the semantics have to stay the same uh but yes these are variable names so so let's say we want to instead of mapping this with uv in uv space let's map it in world space 
[03:20:42](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12042) so we have world coordinates uh and we want to uh we want to be able to send the world coordinates from the fragment shader to the vertex shader or sorry 
[03:20:53](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12053) vertex shader to the fragment shader so we need this in our interpolators okay so how do we get the how do we get the world space coordinates well um 
[03:21:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12064) we already have the local space once which is v dot vertex so if we do um usually actually i usually call it world position because it's literally the world 
[03:21:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12073) position of this uh pixel right after interpolation um so what we can then do is we can do a matrix multiplication so we do um mole 
[03:21:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12088) which is the matrix multiply function what we can then do is we pass a matrix in here which is unity object to world and then we multiply that by um 
[03:21:41](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12101) the local space vertex position you can also use um the model matrix if you want if you want to be a little bit more technical this would be the same thing all right 
[03:21:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12114) so now we're transforming this from local space to world space by multiplying it by the model matrix and then we can use this in the fragment shader and as always if you want to 
[03:22:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12126) debug stuff output it as a color so let's do return i dot world position uh oh the world position is a float3 so we might want to make sure 
[03:22:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12140) oh actually it's vertex i'm not sure if the fourth component of the vertex is one here so i'm just gonna make sure that it is uh possibly dumb question multiplying by 
[03:22:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12157) matrix has to be done with the mole or can you just use matrix times vector um i am not sure i don't think you can do that but it might be possible i just always use the mole function 
[03:22:49](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12169) the mole function also has the advantage that you can flip the arguments to transpose the matrix um but yeah um maybe you can do that with just a 
[03:22:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12178) multiply operator as well okay so i don't know if you remember when we talked about this during our math class uh but when you do a matrix 
[03:23:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12187) multiplication uh where you transform some three-dimensional vector you usually pass a float4 into that or a vector four 
[03:23:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12196) where the fourth component um depending on if the fourth component is zero it's going to transform as a vector or a direction but if it's one it's going to transform 
[03:23:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12206) it as a position meaning it's going to take offset into account if it's zero offset is not going to be included it's just going to be the orientation 
[03:23:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12215) and scale but in this case it's a position right okay so then we want to output the world position xyz alpha channel doesn't matter in the shader so we can just give 
[03:23:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12224) it whatever value uh okay there we go and now we can see like would this make sense we're outputting the world space position right uh green increases when 
[03:23:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12236) we move it up uh we can see that as we move it around um it gets more red on the x-axis so it very much looks like we do have the 
[03:24:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12245) actual world coordinates here right so we scale it up we can see sort of the the unit cube um in the zero to one range over there uh so that that seems valid right 
[03:24:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12256) because it's especially visible if you put it on a cube i always love the the color gradients you get when you're visualizing world position like this 
[03:24:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12271) there we go we got an rgb cube um so this one is now showing the world position of the current uh fragment that we're rendering 
[03:24:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12280) cool so we got world position all right so we've got the world coordinates um and world coordinates are in 3d right we have it's along all three axes and we can slice 
[03:24:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12291) this however we want like the rotation doesn't matter we're just gonna get a a slice of that unit cube right so we know that this uh value now works 
[03:25:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12301) actually i'm curious if one is the default value here so i'm just going to try that seems like it is cool that makes that formula a little bit easier 
[03:25:11](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12311) uh so this is object to world uh so what do we want to do with this uh right we wanted to map this texture um with world space coordinates instead of using 
[03:25:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12326) uh uv coordinates uh so if we think about this what axes do we want to map this texture to so it looks like it would be on the um on the x axis and the z axis the blue 
[03:25:39](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12339) one right so it wouldn't be the x y axis because then it would be projection along the z axis so that would be side on projection 
[03:25:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12348) so we want this to be a top-down projection for our 2d texture um so in this case if we want to get 2d coordinates for our texture uh we can call it a top down projection 
[03:26:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12361) and then we do i dot world position dot x z so now we're going to get a vector 2 out of this that is built from the x component and the z component 
[03:26:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12373) of the world position so now we could output this as well so we can output the top down projection which is now a vector 2. uh and we can see that we now indeed we 
[03:26:24](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12384) have a two-dimensional coordinate here the y-position doesn't matter at all but it is projected top down right so if we like rotate it like this 
[03:26:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12394) uh we kind of lose data and it's uh it's not really a planar projection along that axis anymore okay we're gonna use this as our coordinates 
[03:26:43](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12403) for the texture so we don't actually need to uh we don't actually need to use the uvs instead we can just input our top down projection 
[03:26:52](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12412) which is our top line coordinates and if we then go back to unity our texture is now mapped to world space so if we move this uh this plane it doesn't matter where we put it 
[03:27:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12426) or even how big it is this texture is always always always going to repeat in world space so it doesn't really matter how we move this thing around right 
[03:27:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12436) and since it's a top down projection edges are going to get all stretched and funky um and if we start rotating this you can see that we get like stretching along the edges which looks kind of 
[03:27:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12446) gross but it works pretty well for like a relatively flat stuff right um so so this is a very very common thing to use if you're doing like 
[03:27:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12455) terrain um so with terrain you quite often have like vast stretches of land and then you like blend between different textures and sometimes it's 
[03:27:43](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12463) just kind of easy to just use a world space coordinates for that instead of having to like update some uv coordinates on your mesh every time you change the size of it or whatever 
[03:27:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12471) so it can be can really useful to you to have that in your toolbox um yeah we do not have time to talk about normal maps oh but there's lots of stuff we can do 
[03:28:02](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12482) now now that we have textures okay so something that i mentioned before is that like a lot of the things we do like it's all colors in the end and it's all float force in the end 
[03:28:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12494) so we can replace almost anything with anything and it'll just work in the end right um so just to show an example of this let's go to let's go to a good old good 
[03:28:25](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12505) old photoshop and make a texture it's gonna be it's gonna be a beautiful texture uh we're gonna fill it with just black in the background 
[03:28:40](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12520) all right let's draw some some patterns or of some sort cool what a pattern um actually let's do a little bit more of the islandy bits 
[03:28:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12536) perfect rate my pattern why did i name it pattern jpg what a weird name okay we dumped that into unity cool now let's go back to 
[03:29:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12550) our shader uh we want to have another texture input now we're just going to call it pattern um there we go oh i didn't really explain what this part is 
[03:29:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12562) this is what is going to be assigned if you have nothing assigned to it um so if you want this to be white if you have no texture assigned then you type white 
[03:29:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12572) i think there's white there's black there's gray and then there's a bump it's basically a normal map a flat normal map color um so a normal 
[03:29:41](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12581) map that just points directly upwards okay so pattern uh let's let's bring in our pattern uh we don't want scale opposite for our pattern i'm just gonna just gonna have 
[03:29:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12594) the sampler there um and is there such a thing as a single channel texture or always getting rgba there is something such as a single 
[03:30:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12604) channel texture uh not all of them are supported on all platforms though and some of them are only available as like render textures rather than like 
[03:30:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12612) textured data but yes they exist um there are like tons of different like shader formats or uh texture formats you can use okay so uh we i don't really want to use 
[03:30:24](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12624) the scale transform stuff anymore we don't need that um let's remove it let's nuke it uh okay and then we have our pattern 
[03:30:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12635) so what we can do now is that we can remove the uv animation uh okay so we have the color of the the grass right let's or the moss let's call it moss just to be a 
[03:30:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12647) little descriptive uh and then maybe we can have another texture now because we have the pattern right let's call it pattern equals and then we sample that texture just like we 
[03:30:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12658) did before but for this one we we can you just use uv coordinates right um so we've got our pattern let's just make sure that that works 
[03:31:08](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12668) um let's assign uh the pattern and then also make sure that we use the pattern texture there we go so now this is the thing 
[03:31:19](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12679) that we just drew in photoshop uh the very beautiful 10 out of 10 pattern so like i mentioned before like it doesn't matter if you're sampling a texture 
[03:31:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12688) doesn't matter if it's uv coordinates doesn't matter if you're getting world coordinates the things we've been doing before we can do that just as well using a texture 
[03:31:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12696) sampler um as anything else um so when we were looking at this like um we made this wave thing right like the the get wave function um 
[03:31:49](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12709) like even stuff like that we can use the texture for right um so uh let's say we change this just to a coordinate because in our radial anymore 
[03:32:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12725) there we go [Music] okay so we can do this with the um the textures as well so let's say we want to do a wave that's based on this 
[03:32:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12742) pattern that we just drew that is completely legitimate and a thing we can totally do so let's try that let's do get wave from this pattern 
[03:32:33](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12753) and then we have an undeclared identifier and undeclared identifiers happen when you don't have tau in your um in your shader 
[03:32:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12766) there we go so now this thing is based on the texture instead of being based on um some math right um it's a little a little bit compressed 
[03:32:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12776) looks a little garbage if you zoom in um you can of course change a bunch of compression settings uh you can set the compression to none in which case it turns off compression 
[03:33:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12785) uh but if you turn off compression then obviously that's gonna take more memory uh in your um uh it's gonna occupy more memory in your gpu 
[03:33:17](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12797) um might also want to do that so that it's not flashing all the time um but yeah so so like i mentioned you can just like keep doing this like over and over and over 
[03:33:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12807) again of like swapping out values and spaces and coordinates to achieve all of these like funky effects that you might want to achieve um anyway that's just an example for how 
[03:33:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12818) you can like swap these values out um okay otherwise we now have this pattern i should specify that that's the x uh component 
[03:33:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12831) um right so now we can do stuff like uh what if we want to have grass wherever this thing is white for instance um well we can use a lerp for that right so 
[03:34:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12843) um let's say float4 uh final color equals lerp from in this case i guess we can just have a constant of 
[03:34:19](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12859) um let's make it a let's make it red let's blend between red um and grass right or moss based on the pattern that we just had and that's a float 
[03:34:35](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12875) before and then we return that color so now if we go back we're not blending between the color red and our grass texture and these are 
[03:34:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12886) sampled in different spaces right because one of them is sampled in uv space so if i scale this the pattern will also scale but the grass will not scale 
[03:34:56](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12896) so we can sort of move this around and they're kind of moving independently of each other um which is which is kind of neat right um so so you can mix up these spaces as 
[03:35:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12907) well not everything has to use the same space and then obviously you can also blend between different textures so let's add another 
[03:35:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12918) texture let's call that rock uh all right copy the variable um and then we have the moss here and then we can replace this with a rock 
[03:35:39](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12939) there we go use the same top down projection for that and blend between rock and moss okay let's go back to unity it's white 
[03:35:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12951) because white's a default and we haven't assigned this yet um so let's replace that with the rock and there you go so now we're blending between these two 
[03:36:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12961) uh textures and they're also both um in in world space here right um so so this pattern is only changing where they are blending uh but it's not 
[03:36:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12972) actually changing the mapping of these textures right because the textures themselves are sampled in world space and obviously this blend looks kind of 
[03:36:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12981) horrible it's very very like obvious that it's crossfading between two textures so quite often you would use other like noise textures to modulate this blend 
[03:36:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=12991) but i don't know we probably don't have that much time to look into that now and i also need some time to uh create some exercises for y'all okay i'm gonna make a unity package 
[03:36:42](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13002) out of all of these things and um i'm gonna send it to you so you have the code in case you want the code um if you're watching this on youtube in the future 
[03:36:52](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13012) it's going to be below in the description i'm going to link the things same thing with the assignments i'm also going to link that in the description but we're still stuck 
[03:37:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13021) in the past so there's no description here my students are saying the future people should like comment and subscribe and hit the bell for notifications there 
[03:37:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13030) you go uh any more questions before we're done so we did textures that's that's really good lots of fun assignments we oh one final thing that i should talk 
[03:37:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13040) about um which is which is a very neat topic which uh some people might not expect to be a thing that shaders have here's a fun fact 
[03:37:30](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13050) actually let's use this texture as an example it's probably a good one okay so when you when you think about a texture this obviously needs to be loaded into memory 
[03:37:39](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13059) of your gpu right it has to load this whole texture so that it's ready to read from it as soon as you want to draw something with it there is something that is really useful 
[03:37:50](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13070) to know about when it comes to textures is that this is actually not what lives in your memory it's not just what you're seeing in front of you right now 
[03:37:58](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13078) you can make it so that it is that but that is actually pretty bad um and this relates to something called mipmaps or mip maps usually just mipmaps 
[03:38:11](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13091) and what mipmaps are is that you have basically copies of this texture but down sampled to different sizes so the way that this is going to look in your 
[03:38:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13102) memory in most cases is that it's actually going to take twice the amount of memory worst case four times quite often 
[03:38:29](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13109) your textures are not properly copied in photoshop oh god i turn off snapping view snap there we go so what what often happens is that 
[03:38:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13124) your actual texture in in your video memory is going to have a downsized version of itself quite a bunch of times and usually it's 
[03:38:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13134) it's a halved in size for for every uh scale along the way so it's something like this i'm not perfectly aligning these so this couldn't actually be used 
[03:39:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13146) in a real world scenario but but you get the idea right all the way down to a very very very low resolution and this one is just a bunch of bunch of 
[03:39:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13155) pixel so we end up with is a texture that sometimes takes like twice the actual amount of memory because it has to fill these extra mip spaces in here 
[03:39:24](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13164) um and you might wonder like what is the point of having mipmaps like why do we even do this right it just takes up a bunch of extra memory and the fact that you do that is or the 
[03:39:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13176) reason you do that is because if you think about how shaders work they if some texture is far away you have some uv coordinate on some pixel 
[03:39:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13186) it's actually just going to take the color of that pixel and output it um in a very naive way if you don't have something like this so we can actually look at 
[03:39:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13195) how like how what would that look like if we turn off mips so i'm just going to make both of these moss uh this might be difficult to see 
[03:40:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13205) on stream is that actually how they are packed it depends on a lot of factors uh if you have like i think some of them like do 
[03:40:13](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13213) one on the side and then it's sort of up in a like sort of spiral-like manner like i think some of them do uh oh god what's the order of these um i think you can do this type of thing 
[03:40:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13228) which is a little bit more space efficient than whatever but if you have an isotropic mips it's not going to look like this at all because then you need 
[03:40:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13236) anisotropic data and not just isotropic data um so it's a simplification of it okay so so if we want to turn off mipping we can very well do that so if we go to 
[03:40:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13248) our moss we can set an isotropic level to zero we can uncheck generate mid maps and now it might be difficult to tell but there should be a lot of noise happening 
[03:41:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13263) now right anisotropic is for anisotropic filtering right yes um so you might be able to tell that this is kind of flickering and it's very noisy 
[03:41:12](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13272) right and this is because now we don't have the mip information we don't have this uh pre-down sampled versions of this texture 
[03:41:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13281) we could do the same for the pattern i guess it might be more obvious with this pattern since there's more contrast in it so if we turn off the mips 
[03:41:31](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13291) uh although this one is more soft no no my bad example is too soft but yeah so there's lots of noise here okay um so the um it's actually not so the the reason for 
[03:41:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13305) having these mipmaps is that they are down sampled so that when the uh texture or when the shader is going to sample from this texture 
[03:41:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13314) it can sort of guess at how uh how far away the texture is and it's actually using partial derivatives to figure this out and based on the kind of the 
[03:42:07](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13327) the rate of change of the uvs that you're sampling with depending on that it can pick a lower mip that matches the distance at which you're 
[03:42:16](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13336) sampling this in and then there's all sorts of stuff you can add on top of this the very basic types of mips that i show you here 
[03:42:23](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13343) that one is purely distance based uh it doesn't really care about angle it does to some extent but it's isotropic um you can enable anisotropic mips which 
[03:42:33](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13353) um that one stores uh squished versions of these as well that are like squished on some axis so not only do you have the isotropic ones 
[03:42:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13364) but you also have anisotropic versions that are scaled on a specific axis right which is useful for when you're viewing something at a very low angle 
[03:42:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13374) um so if you're if you have ever heard of like anisotropic filtering that is what anisotropic filtering is uh it stores some number of mips like this um that 
[03:43:05](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13385) are squished um along a specific axis uh so they're like pre-filtered and look really good at like low angles which is really really useful for uh like 
[03:43:15](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13395) games where you have like a camera that's close to the ground like fps games or whatever not as useful for like rts games anyways that's anisotropic filtering 
[03:43:24](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13404) um so if we um so if we enable mid maps again but we don't have an isotropic filtering that if we view it at a grazing angle you might be able to tell that it's kind 
[03:43:37](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13417) of blurry here because now it's picking from one of the lower mid levels or higher i don't know which way it goes so now it looks pretty blurry on the 
[03:43:46](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13426) horizontal axis right but if you enable the anisotropic mips the blur disappears immediately because now we have pre-sampled versions of you know what would what would an ideal 
[03:43:59](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13439) squished version of this look like along you know both the cardinal directions right um yeah games tend to say that it will induce a performance hit but i rarely 
[03:44:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13450) noticed any from that is it mainly just a memory issue i think it's mainly a memory issue but yes most games say that it affects performance so i would guess that it 
[03:44:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13458) actually does um but yeah anisotropic filtering generally generally does take more memory uh but it could be something like the 
[03:44:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13466) partial derivative needs to like separate out the different axes in order to like calculate that and that might be slightly more expensive but 
[03:44:33](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13473) yeah i've never had issues with like performance when it comes to that so oh and then there's a third concept which is also really useful so you can have different filter modes 
[03:44:42](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13482) bilinear is the usual filter mode and you can also have point filtering so point filtering is what kind of gives you the minecraft look um where it doesn't blend 
[03:44:52](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13492) between the colors between each individual pixel it just goes to the nearest neighbor right so that's when you have a completely unfiltered 
[03:45:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13501) texture sampling bilinear means that it's going to blend between these textures bilinear is is pretty much always default at this point 
[03:45:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13510) and point sampling has a lot of anti-aliasing issues unless you make a very specialized shader for it and then you have trilinear trilinear means 
[03:45:18](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13518) that not only does it blend between the pixels smoothly but trilinear means that it also blends between the different mip levels so it used to be that if you don't have 
[03:45:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13532) if you don't have trilinear filtering enabled you could quite often see like a wandering ridges if you move along the surface i can see it on my screen uh 
[03:45:42](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13542) like there's one ridge here where it's switching between the different mip levels um probably not visible on stream but if you enable tri-linear filtering 
[03:45:52](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13552) it's going to blend between the different mip levels in which case we're not going to have this blurriness issue again mostly useful for like fps games where 
[03:46:02](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13562) you have a lot of low angles looking at terrain like this in which case it's really good to enable all of these things and but for rts games uh it's pretty 
[03:46:10](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13570) much just a waste of memory okay cool we did it we talked about textures um all right how is the filtering applied is kind of 
[03:46:21](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13581) post effect this is very low level gpu stuff it's not a post effect this happens when you sample the texture i don't know exactly where it happens in the gpu but 
[03:46:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13592) um but if you want you can you can explicitly sample a texture at a specific mip level if you want to the in some cases you actually have to 
[03:46:44](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13604) do that but if we do for instance let's just return the moss um let's add a mip sample level mid 
[03:47:01](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13621) and that's a integer oh sometimes you can sample float i have like weird behaviors between platforms um with this zero is the highest level of detail and 
[03:47:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13634) higher numbers step down into the into the lower levels of detail um all right so we've got the mid-sample level let's call it a float so if you want to 
[03:47:25](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13645) sample a specific mip level uh you can use a text 2d lod for level of detail uh and then the um then the uv coordinates are going to be 
[03:47:38](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13658) a float four uh where the mip level lives in the remaining parameter i think that's how it works i don't know if i need both of them i think you have 
[03:47:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13668) two a float two here if you want to do like separate for the x and y coordinate or the u and v coordinate uh and that's for anisotropic sampling 
[03:47:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13677) but in this case we we just have a single value so now if we go back we can change the mip level right here right so we set it to zero we have the 
[03:48:06](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13686) highest level of detail and we're going to get this issue again where if we're far away it's going to look all noisy but if we can change the mip level here 
[03:48:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13694) and if we're really close it's going to look blurry but if we're far away enough it's going to look just just fine right um but yeah so this is something you can 
[03:48:22](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13702) use mip levels are sometimes exploited for like specific effects um they're quite often used in lighting like image based lighting 
[03:48:33](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13713) uh sometimes you store like uh like convoluted convoluted as in the uh lighting scientific term convolution of light in like a cube map for instance 
[03:48:45](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13725) in which case the mip level can sometimes be sampled depending on like if you want to have a blurry reflection versus a sharp reflection you can read off of textures in 
[03:48:54](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13734) different at different mip levels so sometimes you do want to get a specific mip level um for like technical reasons for artistic reasons and so forth 
[03:49:03](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13743) usually you just let the gpu calculate the mip level automatically in most cases another caveat is that if you sample textures in the vertex shader the vertex 
[03:49:17](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13757) shader cannot figure out mip level automatically so you can't use the text2d function inside of the vertex shader but you can use the text to the lod 
[03:49:27](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13767) function in the vertex shader so just a little thing to keep in mind that if you ever want to use textures in the vertex shader always use text 2d a lot because it 
[03:49:36](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13776) needs a specific mip level uh supplied to it um okay that was a that was a lot sorry for like rushing mips mips and textures 
[03:49:48](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13788) but i wanted to go through textures before we end for today okay i don't know when i'm gonna have the exercises ready any questions before we're done for 
[03:49:57](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13797) today uh if the texture is rendered at a big distance only small bib is used it's a whole texture atlas still loaded into memory that depends on how you set up 
[03:50:04](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13804) your like texture pipeline um there are like some games that can like dynamically stream in and out different mip levels uh which is why sometimes you 
[03:50:14](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13814) like sometimes games prioritize lower mid levels and that load the higher detail ones later um like i know um unreal engine 3 i think had a pretty aggressive uh feature like 
[03:50:26](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13826) this uh where they prioritize load times really really heavily so you would sometimes like spawn in like some area and you would see 
[03:50:34](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13834) everything would just be a smeary blur and then it would like get more and more detailed as you uh as time goes on um so sometimes game images do that yeah this is very informative looking forward 
[03:50:43](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13843) to the assignments in the next lecture thanks for the sake of efficiency can you prepare the assignments ahead of time like before the course starts or something also more likely to guarantee 
[03:50:51](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13851) the quality of them as well i don't like doing that because i don't know how far we're gonna get in the course um i feel like if i force specific 
[03:50:59](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13859) things that we're gonna cover i'm to either rush some of them or i'm going to have to like draw some of them out in order to not cover things that i want to cover in the next one 
[03:51:08](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13868) so i tend to prefer to like i tend to prefer to do this on the fly because then i know exactly what i've taught to you and what i haven't taught yet 
[03:51:17](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13877) uh to make sure that like the assignments only cover things you already know but but yeah but i mean if you don't like the assignments feel free to tell 
[03:51:24](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13884) me um if they're not good but i try to make them good regardless even though i do all of this basically impressed so can you get these scripts as well 
[03:51:32](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13892) yes um i will send you all the things okay also thanks oliver can you swap out the stone texture with a water one and make the waves again i don't have a water texture to go so 
[03:51:42](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13902) not really okay cool i guess we don't have any more questions feel free to feel free to play around with traders uh until you get the assignments 
[03:51:50](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13910) but yeah otherwise uh just experiment there's a lot of like fun to be had and just experimenting with shaders um and i will send you i will send you all the code uh from today as well so 
[03:51:59](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13919) don't worry about that including the textures i should also fix all of the mip settings that i destroyed oh actually um if you want these assignments as well 
[03:52:08](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13928) uh i guess feel free to head out head over to my discord and i'll post them in the um in the dev channel probably i'll post them somewhere um in case you want this package as well um 
[03:52:20](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13940) for those of you on twitch but yeah thor screaming i should wrap up the stream um i hope this was informative or interesting or fun 
[03:52:28](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13948) or whatever also huge thank you to future games for like even allowing me to share this publicly um it really helps incentivize it for me 
[03:52:39](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13959) because i i want to be able to reach a lot of people and it's kind of a shame to me if i do like a whole thing and it only reaches like 20 people i 
[03:52:47](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13967) think it's really nice that like even people who aren't part of future games get to take part of this so i'm really really grateful for future games too 
[03:52:55](https://www.youtube.com/watch?v=kfM-yu0iQBk&t=13975) for allowing me to do this it's really nice of them yeah i think that's it thank you all so much for joining you 